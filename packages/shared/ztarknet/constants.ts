import { type CompiledCircuit } from '@noir-lang/noir_js';

export const CONTRACT_ADDRESS = {
  ZTARKNET_TOKEN:
    '0x01ad102B4C4b3e40a51b6Fb8a446275D600555bd63A95CdcEeD3e5ceF8A6BC1d',
  ZTT_TOKEN: '0x3adfa5dfa8350ea015fe370434ef83245553ea814f4f3be67f5bb555161378',
  AMM_ROUTER:
    '0x4bac4f7f1cb007666c29644c6569d070f8bd20b103c5c710ad10ec98eec73a1',
  OZACCOUNT_CLASS_HASH:
    '0x01484c93b9d6cf61614d698ed069b3c6992c32549194fc3465258c2194734189',

  ZKPAL: '0x3bcb7f308a24a48c930ec7fa816cb86824217bd7945fba2f4e9f79c1ed7ffe9',
};

export const ZKINPUT_LENGTH = 16;

export const RPC_ZTARKNET_TESTNET = [
  'https://rpc.regtest.ztarknet.cash',
  'https://ztarknet-madara.d.karnot.xyz',
];

export const poseidon2_circuit: CompiledCircuit = {
  abi: {
    parameters: [
      {
        name: 'inputs',
        type: { kind: 'array', length: 2, type: { kind: 'field' } },
        visibility: 'private',
      },
    ],
    return_type: { abi_type: { kind: 'field' }, visibility: 'private' },
    error_types: {},
  },
  bytecode:
    'H4sIAAAAAAAA/829Z7g1zXKWt44EQgLlnHM+gDr3NAIECBAgQGSTTU93D8HkDCZnMGByziabnLMBkzOYbHIy2eQM9l1bej+m9vr0q9Zc1zpH4Zzv3e/a3Wumq57nrurud9w+/1/vfMft9unvuL31rzf/8St8wf93tn/5N5/7Lq8/16+wbT2VfaXQ/LZHN3a3wozHFmvbvTuK97115930++ozzONYmw99Tje282dFV1JaNSwffXeh7Vt2Ke9l85vPW55hi3FtaeNjW3XNp7j8kVs8vmCQ73r6LL+Sn/y7+uH3XI8WfJ5z7iPEFeqoqW9jZDdW3IaP0bXOaI79CFtpY+3udvrXu1zwXT5qzl9EjevwKeUQ8xF82kZuW8lb9aUdfAljblvd3TbTdG4r2zxyaeU4juRaLmsr6Yr3Rp7Ju77N51rn/UUfN0Z3xbzf8QWf+frd8X4/VmnumJ7ZxBFXjsntvjM752soflvZreILj6fMNt0RV/XBz7ZWXf0dD/wO302tl1zX7HPwSviZg9vGEf1R/dHjwUs1pqs9tTCic2XjRdsyQ3eeNTPlBbpduF4eOecvdh4Xa+CI/Oza+miNHwzEqbzxnffN7Y1QVsNWo9tr32MZi0894tbcGkeNR77ivZFn8m4XrJd3vz12vdy912XN5BndvrfhRil9ed9SSIcE3X206BMv1zH3uVbPeZZRUk5xjtRcXC9x7Lymw97cvndC2pBH0sgiddU5WD1bWG4e1ZW+l0QE30Oqe20kmbjXtGKpsUx5zu9+wff4HucxujXLyqyKtnbSR661bbwnR51htTRiy6zb3luq2xZC7aNnvoxY+IqKj/2K90fG9x4XzPuL35473sr4vvgF8/4SF6+bsELy7WhruLB4Y9JoZOyxxdAKi8PvW5s1xbGNujded2YQoveFVO6PFeLrdePRWQRt52IQ+VVajcyzFkk5LseJLphpedeOfOyu5LH1jhDK3R1b249+1bp5z/OcE+mvbPzqY9QtHmXvLAy/TRZFdVXGjiJJpe0ZLVlWK2ULjmmP4fIe1xXvj4zvPS+Y93vdnnvdyPje64J5v/fF68bXwtvAImkZ5R7yFnp16zjc1ssxG7oJPePDyhtZo+5l92XMo+9jWwuf4u/WTUPnDNdzqS7sR/J17/VY2AM+nGl1vo5UXeT1TPGotcZQ25jVz5BnXu6qdfM+53VDQCgs3TAHKc9nP+M2u68Ma7A2do/PcTHnmo8VY5wlHLOnGXomGe/X6BUZ3/tcMO/3vT33upHxve8F836/B8/7XV+vG9f2yuvt0VaLZLOHvbrRj4ws6eSUlvZVB459hhTrhtyaDD63sPfNY+9FW5xzolX3Scw9xwqr7pN38f0ueC7vfx7jtnkm0NfeV+9b2HqsZR5b7UfqJRJj9gpJqH0mhF5o2zrqHjf5Z1sOZV7xPsr43v+CeX/A7bnXoYzvAy6Y9wferl2Hkrl4RdaajC+J22QBjlpYdI2F08MYG0vIJ8/KnBOjERqcYMzl9lmrf70OrTry9Tq06sir1uEHnedcQ2XR73xXBBoXgRKkubgtmB9QYgYXIwQsODdiDvvwmdy5wR3n0cZetyveRxnfB10w7w++Pfc6lPF98AXz/pDbxfkwRRf8GmUrCEBA8MwsopJTQfnxWi9kY20w7oHzqDnGUAIT4ie6h9rVu3xo1KV369CoS69ahx96XocxrQEi7KGyIkdY0PV9hj10nwhEMBKBhHEBOgkhs+zbsbcVPV/iGCWGK95HGd+HXjDvD7s99zqU8X3YBfP+8NvtqXWpaJ9zzrbqUonh59hj1aXyLn74Bc/lI85zznsOUk7go5bfjnpsJQzS41H5n+I61Ti+rex6jHylYxCPjqMI1q4zhUvyoYzvIy6Y90fennsdyvg+8oJ5f9Tt9tS69PU6tOrS1+vQqkuvWocffX4uk++oT6p3K+0UY/OaZHEAZyEsSMV5OSpOG+XwvO0+hlkdenVRVaIq649yxfso4/voC+b9MbfnXocyvo+5YN4fe7s9tS69y4dGXXq3Do269Kp1+HHnMRKWWj6OEbw/iF2F7F1dZmnGY2fgq6fFl7cdhV93rNHq5nL2W091pdnGFe+jjO/jLpj3x9+eex3K+D7+gnl/wu3idWjUpaJ9zjnbqkslhn/s7XG6VN7FT7jguXyi+g5hMDvyswY/+jxWI/CAapwvx4hMF3raURkh163xJfo6+NBtutLmyrld8T7K+D7xgnl/0u2516GM75MumPcnP/m85Vl/8gXz/pTzWkwxpUgR+yjpODo5MaGkp/R5HYMERBnbIaKLiGrKdiH1EPjMscZC/K0XDvI6/ji/sqvHLnk98fd8lM6SHiS27INgxG+i5uenSy7NWKg6FLQk+daXGVN+HX8cTm/1VnqObdv5D4u4NvKkTBiJPZDTjbS/+GT+KOWFjKW6uI4tZ0JGzK/jj585Irb5xRvDJEwSyTY39207wjFmbJmx8M0Skuo8wgyeaOpC3yjr1xbcm/hzV981xt1PeeAz/tTzuBpfGnKmbjVEzEsr4KxIfHWl5oSfFhZWtzUQGGipiVDbI/qq7DvfbrvEY8v4PvWCd/vTbs+9pmV8n3bBvD/9yectz/rTL5j3O0+fFQLFzHbsx8yzrsZSDlky9GAl4/vlBaf6WRApY7rYu0s7i9KjrTvrwL/0ON9pqbqcZ+EcjZA25K83fMhiSeFhoAREn5IrprjDFcbA1qxeW+q5+TlLW69jWQjSoIp42tx25LnXPvgFqdUF68ppHDOUjvLxI83Mj26z48sdbgVnVcJdLAu+R+JWh0oUtw0QROp+MNa97+5IzIsCLhRjby1F/FPlhxhsIfC1VWN7E8seHcPPscwaF9/5wPflS57neAw+48D4UQsf25Z77I4vs7YcDp5Kx5riEwtfLcioj+JTrfxsK7ltR6tXrBMZ35e8YJ18qdtzxwcZ35e6YN5f+snnLc/6S18w7884r79ELSvWoxOkEEjLkex7cLPFgSBwI5VaeekJHQAPGCUQvg7XWJLEKbfe1mO6rcac405UOVo49uoLpWspmU2WdpgHFm7uTqprhCOs4QLDMmRs4d769Hcaz60g3ko61eNI6NGcWHv1iIQcNFnNvvLRe58ADz4MMNRGQ85kSuTDrbu4OKUZvhGGw15iJbBuo7hj75Ew6ztBKmR4lCcQQXiL97NOSEpapaxIgHsTF7/Iq3lb88E5Llpj7DkuWmPsZzzw3XPncYXtcB6Ah2YvkSxLjp48DNR6W3A3ZDtVn75EY4chRVbZtbEEcGX+55K+Ixmfu2DN+dtzxxoZn79g3uHJ5y0fGi6Ydzy/57m3gDvdcZFSz5yJGmYTA03AZV1uEkqHsNuDTyEYhqN36PW2szTQdfIZd3UtFOLG6oeCtXqIWwvgsWPfXIxELsLqchsh9SB4SSXKEWzgbajblg6/3F2MbXC8QJGM2LhtlKES9u7YiCf7KvyDQrwlZqREvQfbhw5NoiFjGOihfNTXMdZlaSZsvhTQ3Nx7T0Q4Qn/rsj3RU0bau3C0QPyZO+SdDEGMKtThPJN6S3t+0dfP25hblPY0xutzjLXGa5WTjfE6PvA9Tuc5jjY9adXzhXuKqhvJcmJP0uTNpvIeG9W/raQQw+pw23EwfJ5C71JbdZdwTxlfumD95ttzxy0ZX75g3uXJ5y3Pulww73r6rHDUuWo+AmCg8/Liy1G+a5eSw4HXI64ugs/akISY6JhGIMw2l0vg1d9f6mx38TqyHGLaqJMck9pIRnCDFptvi4Db9+lZ21LH7IVCKap7lIPYmWWn+YxbuK+7UFspqNyNZNL3xJrsrvtOiRMNS8ghRtfZDwqtlEg2qZEQ+aELEWjZ2j0rSJBNEtHg4/bYViMQHttGvTGEQPSPGTpQB/RkdsKk62N6kOGx+HWBmPMmXr/b63kb85TSxMbYrzSxMfaf47U19iutYIz99YFrYjuPCyImlXRqAXVS5YsjM4sQN9hTXzxfGJpHJ4zopTRHjdr1SaGa75Iy3rpkj5uMb7sgFrTbc8dAGV+7YN5f5snnLc/6y1ww7888jzGKtI1S0Nn4ezs0JHoiI4GxL+S4LOtCKQhCytpEnce8paMmaQbJI7xwvzseUkUqJSgF6pYKuCM0DZ+oJxEKe0ZPpSA15CjnJLjYxobGds2lTVoafbyP/RFnvO+TOaYJzSV+ZaLF9Eej+gwb3kslovUySE1yMsa+L5h3jdLSvMW7mldwB8jHE1X2QhqjoM0XF8sm/5kE6MfwEOgpTdALA7ORYV5avlblG47pTez/Yq/mbc15qhZpzCNKqxvziNLqxjxyjv3WPHKO/dY88pkPXF9f9jyusbVJzQKgzpfMf6pFah1gnX1thcLyzp8t9FQBpMs/2zz1yVL9nsLo1/TWy/i+7AVx5cvdnjueyvi+3AXz/vJPPm951l/+gnl/1u1ce9tQ3hVQskE0QRov0YSg56nBsc5XpLSOgudN97z4ri9CDSlnSO/6ym/rIXwkLKXmEN0xiZ6PHVZ6DCpPye+BgECxUgIgXDuXBLImTvLBc2ysr97vmA8BiUpoaY0g0WOkwL+FJuSfjEeQoTI4Pd9IozbY+bVEcy950O1jEOHGvYcofGv8n4Pffmwpy77RTE4ZFYQvDQYNBLS5owj0kmxIYN7XIM0dLvXxJo+8++vnbcyfKo8Yc5KqKRtzkvIQxpykPIQxJ53ziDUnnfOINSd91gPX6lc4j4sKeuQlL2vyMkSK41tbyfWaZA0Pf1AJijXkST6KrkGyZl5h+FDgmZDd2+3xMerN+B4do77i7bljs4zvK14w76/05POWz/lKF8z7s89j7JgBqE51NZb1csTTnjN8P/GaE5cicbZJ2ExUUONYGehDvKzQroOq3Mt5evf9xKLltgQVKgt4NAl2fYtE+NzJZ9tkLfH7ZCMMZQJid3MhEHeoguyg4rs6hJ8EEz7lwIXBoHzvkmyk2VaO0ilTkgiEu4eNWjDJjVgLktujpFTZNHNXh3CUcFnMK0zoHHE8jZJQmKtGWBkF3tBY3b5OPwspO0uj35EJ6MRVqYe8yUnv8XrexlysuJYxv6mcZMxv55xkzW/K2xjzm/I2xvym/L4xv33W7XH57bMfuO6/8nmOjTId1XMmxcpxs42WZ8osetbnTAPUjRTcmXBnwTO9MXdPiZ2HH5Fp8hgfHu9kfF/59vh491Vuzx3nZXxf5YJ5f9Unn7c86696wbw/57z+SFT8m+WPq0gFD4KbaS4i4HJrCW/zUtbYRnOL8Fka8o3o4aWNnTD79v3qOToRewGfstroG+mIoEDxY6ekQmYqWUIIS2gw6rJcoDRKGWZbRFr+353nIjKtDDuXgLtlwGFlQJsj0R17XMDGhA4leMWBzByV9BQJk/1IAPWQ7j1XD27x1+SEuX6EtLVIHgfWhc5fD1sg3I5OGhpuE65H5s1p55sK/I323z3XF381b2teV3V2Y65U7M6YK1V+M+bKc36z5krluYy5UnkuY6485zdrrvzs2+Ny5ec8MIZ8tfNznCy9UOdWWMVSO91kuyprclINdZGoItthAOBo50WVuFCE7QkJPRxfYL0kdsr4vtrt8bHzq9+eO2fI+L76BfP+Gk8+b3nWX+OCeX/u+T0n7cjpioQVok/fSBK5FVLRXuuxYk8vh9rE2aCVZNFEkPAUfeMgx6SR3zZXkqFYNBR981EiYT3vByRx83IGOESluT1tndACEQxSQhvSXCG9ukNy4n5X56K6TIkgzJz8QaWN1bgfB9xFsnVOa/d15xNXmaRlTyUsp7L81kJmnY5R5l2dS0712ePAYlYSFeWGDawJ9QnUqz0oVPaJjxRzjD3uG/+f5V35R0E2QLW39pZ+idfP26gR9H4IW95VPQ7GvKv4pDHvqlxpzLuqV8eYd5UXNOZd5QWNeVdxG2PeVRrZmHc/94Hx6Guex3XMjDCXZtEkhecNjeyOrfiD12pWuTuA94zHwi+RZbrndQyXiq+FXHxccraBjO9r3h4fh7/W7bnzj4zva10w76/95POWZ/21L5j356m1nERSLqrb7VissRj42TrLIIpQf2uttkEsxL/xKeSBIEEXg0owgdC+1BruGKxsZIyT0gQ1tn1HoSZSBZI0SFJLTs6UhPKSSrdaXIo+TvIviS/KCUj17kwHPCXClpg2QgeRkockQwdJnWsR+llxOUiG8HkQHAOBuVSyDzERtnx/poOfmPLI6hYhsKpHTJBwdlb33jzVP+Y3SblZDnTJvhe8cC/k77A7voqQ3+Td93w1b6veUAzWmMP1fhtbDlf9JcYcrhisMYervGvM4ee8a83hyqMac7jyqMYc/jm3x+Xwz709Lod/3gNj29dRa0g2V7flKyWUIccI+HUUx/dLOMl9EIZaaWn11Erh4ZXFI+6+770WXulLekRlfF/n9viY/nVvz53LZHxf94J5f70nn7c86693wby//u3snYfreNI0dnJ4qQjUmWYdK0qN8iBrEFzJHyFSXD28A7p2Twbep8SA3uUz7jjzqixf4tpeuwSGRmTGdpOEYqEES9gLOQ0GuHDuB+u7HoDcSV5qAaF8v59rSwSSxJKbeawtyrHShwuLgunuomxWmFNKnRE5goYmKo/D+T0RMQezT/fnMsmen4Of2Ao5h8TMUpazqPkyAAIHomZl1jupctR+jGMS6ZMkkx0QXbc3Ofy9Xs3bql1Ub49RDyjObNQDej+XTQ+o3h6jHlCc2agHVA436gHVO2fUA8o7G/WA8s5GPXDO4VY98Hm3x+mBc2yzxslvoGNG4tuh3Lw7/naXvd1hn3XmstD1LJhR3T75JZ1idEy4jcXHgeBC6mu75H4XGd83uD0+P3zD23PnRRnfN7xg3t/oyectz/obXTDv/+G8/o6aAxnMbbsnCFMjihV2vcu+ilHJzumQ91kOCnUuDc+iJMfiiWdfYXOHfMadp5frZP0sefZ9I71SMUYqv0SCXZpojw4UGMQZ/oBidmo+lwbHp+odCL3tnqW/nJs9SV8k29kpB4dNUDo6wIcifb3Eqz3PONJA0WDJQ3KT3LlCDqW/zRka6I6Jfj+I98nLXkNmVEg7u9wiCFVnyi0WVvzmyLdNIvNBhZsomoJ/owfe+/XzNuogxdKN2kL1VRm1hWLpRm2h9wvatIXqqzJqC8XSjdpC6QGjtjjrAau2UJ7eqC2UpzdqC80Ybdri698epy3OcdIac7/xeY4HUbG3yvuVqRLE5YhUvIrN8wm1yqltpbJC900OKqqz1cqCIhpPfBEvjXzGo3ONjO8b3x6fa77J7blzrIzvm1ww72/65POWZ/1NL5j3Nzt9VshHa51Qt60WWJ+UvAnvficPkXgDJfFWpalza5tchU5R/HDSWLavFXzJL2fv32mLHI6+5yRnIkL0USQ5ePTBlDsQCAVrZyFHBusdQYwSW44IlSpd2cfm011Pm9zf2OWK700OKqyEVu+bQzxMuaGjRMYp4xusPzlxkd/tCPmjr3nULa3jrmeb4sNKLXtKBJ2I0gffKAl65MbfrmTIKhd6A7c7eXyLpCiq/lT1ibT8xFv7Ud/n9byNmkrVC4w6RdULjDpF9bQZdYqqFxh1it6PatMpqqfNqFNUvcCoU5S2MOqUs7aw6hTFGow6RbEGo045awurTlEezKhTzjHXGr+/+XmOcsdMlRNXeOmpnPKllmP6Jiewep4IZd7JI8MVAWZz2HIePmwbLyNrj98mn/HovCXj++a3x+etb3F77nwt4/sWF8z7Wz75vOVZf8sL5v0/qvUHt0MzECtZ68FNd5Q+EAY7b3XhL80o2G9Ibkij1BKIaygQObPdufG2OsXFShRpm9ws5Fohv7a4SDWJfJHlyPI5JuXDyH8vwyUCCKKfZR+itO7N+76GjWSDsOh5zdS7HCzQydMtlAD9II6VCJhMfh7EjHY4mMXuKKFsch8TCuiOgZS17WQ0vqEIKXESCzNxKVA/2eRUPMQDbGTtO3WVtO2uB5JHITXuCXHwVu/9+76at1WfKQZi1DyqJmLUPKomYtQ8qp/QqHlUTcSoefR+Z5vmUf2ERs2jaiJGzaN0ilHzqJ5ko+ZRDMSoeRQDMWqes06xap5vdnuc5jnHb2su+Fbn5zjkEo3uM3SmHXL1XafufNRYKZbzIo/EF1UdcWYUiuaJKE7FJ0LLvRw1fcnZ6TK+b3V7fA7st+fO/TK+fsG89yef97fiM/YL5j3O66+L4HC8yZQ0fY1yKnqU+1LgG63KDoXhxpaR+OPgo9bwYwx5zytZYNS31zw5yWEsldjHqml7YQA7KoWQxf+utPshB/HJ1Xee7HFMiRdroFzmpPB0r3lYdGiTrR3jIOQcfWXCZcxksyyXVMk1ecfhJRmzCANJKi2QaTu6tI2Ut2EzfTa5+bgRnA9pMRF9gfIjFWFgSBuSh4hlUNiG1pGLdGaUm7rwNUetbzTP+72et1HrKc1j1E+KzRj1k6r7GPWTqvsY9ZPq5TTqJ1X3MeonvZ/epp9UL6dRP6m6j1E/fe7tcfrprHms+kmxGaN+UmzGqJ/Omseqn7Rntemncy6w5pV5niNfFELJ82XkfrAsV+fB+0noz72GuTpxoZe1p0plnpr6vrbq+R7qEFN7yXlEMr55e3w+Xbfn1hEyvnXBvI8nn7c86+OCeX9r9Z67gHiR61YOsFGccqVn5n3eRtyo5pY9EK3hoiQfFqVce0XAr06C7hGryLv7PaiZIlQiQJFWyGBhkKWOfpB492OwnPcNmvNygwzVIjQA0XRvctlWiSkQ3+76aEPcUFd1RZnCweJrZOlGERnlRDqaG9WvjshB8aA4knzQRpCWW3MqcutOPyHESI/M1TGdQ7L04dtw8KaB+vGVjF3l4CWHokILhdJGHSS9OPFKob/RT+//+nkbdaOqbRm1mNJPRi2mmJFRi6nallGLqdqWUYupPlqjFlO1LaMW0+c12LSY6qM1ajFV2zJqMaWfjFpM7REwajHFjIxaTDEjoxY76yerFlNe2qjFznnFmqO+zfk5jsLa9ryvvDw9HZMowDvm4PqzS+Jg0sxvdN5ncBfPgdHxaCdPYZvrkvOKZXzf5vb43Pxtb8+tSWR83/aCeX+7J5+3POtvd8G8/6fz+mOZVvLmGBthsB+8wYQ5ZAyRZo1G1svk3UVi66u+XPaTJW+XuEfJJW+/LzmTf0s74rH3PInDVVKWROe2ET4D+Ym0QbDjvw9/IKIkgBwBmXDI+V3396MKayPadrcxQmSe7DGSwfI5LhTGXBJpczsaMpKshhxw6LWNn0Kn3J+dhShMa7JckUuEznlsopWc3JYa56gVc+VrITERZnzfUhTNd5BcJrl9vXVH1Qe8mrdVg+p9yTZdp+p3Rl2ntJhR1ymWZdR1qn5n1HWqfmfUdaqH2ajrVP3OqOv0eSA2Xad6mI26TtXvjLpOaTGjrjtrMauuUyzLqOsUyzLqurMWs+q6b317nK475yhrvvv25+fIbFxfqSYWZeXZZfRbkduzNk9qm/zzbfDOO6oY5JkQpAWEb6IJgUvpkr4sGd+3vz0+z3+H23PrGxnfd7hg3t/xyectz/o7XjDv73R+z7OctEB2H4vFHMnqhE9PkHIFjxKc21Lb3CLFoP42smptkiRI4UTIPt/2zG/ef7kPFKmFGFpy2hqpeFZREtLPVZvLkpLIbUT1KL3cspS9R+UNh0C4Y2wEKNK1C56gDO0i0cvldUytlFa3I+RA1ZK6ahoEnr0RCpv8IAq1jnDc32c0jlpAh3XAzMLMEdHVjnIcPYadsmfI6Nh0oBZX2ApfJIk8oqQIQs2hRN7oug98NW+rnlV71Y0aUe9Vt2lEVaM0akR9761NIyrGZtSIqkZp1IiqRmnUiKp/3KgRVY3SqBH1eTM2jaj6x40aUdUojRpR6TqjRlR7dowaUTE2o0ZUjM2oEVXtxqgRFXswasRzvrPmzu+s1lBZTK+Qfii2ygV6ofqxji1Ix09oTp5/2glyJRGZYSahhS2M7Eco5Zr7jmV83/n2eM3wXW7PrZVkfN/lgnl/1yeftzzr73rBvL+bes+Jyns/SMFNeg02/u5OopJLJd22pYT34bVG9szJT6SGOulrK0QOombx8hn3ZxI2ufws9oGW4ZdPclSU8wL7im5SRh2jy1Eg+5TDPxLJl4CBGDsIOxt/dMf+wG5ErBomvHGhYiW9FqQYOZY/2zI5i1rp4Qk0++5wckwiucWPy+Vrd737pAPKt4tc1g6k1kBbpAPdCzPMGQVRmTaJZSexbvmoM0mknXzfDo1Txlt9bB/0at5Wbaz72Gx6U51fYNSb+vwCm95UdVij3lQa0ag3Ffsz6k1VhzXqTVWHNepN1btv1JuqDmvUm/o8I5veVL37Rr2p6rBGvak0olFvnjWiVW8q9mfUm4r9GfXmWSNa9eZ3uj1Ob55zpzUPf/fzHHubG7mRmrOrBF10JUtgeMpc/IdR950Esu+Eqp1X2g8vF3HKznoiBy/ZJedlyfi+++3x+uN73J5bd8n4vscF8/6eTz5vedbf84J5f6/z+hMg6Siwuo6GOQjshMuQpeNvBbnRrxHw+LAFmwe1x60gO9GJQ/5JyS/v+d2+CeLDIN4RgEdGaBLMyakEUfIhjs2RjeQ0ZIl2rRLH1oGsTagOBNFOYfuOSbLeUDlk2n33hWyG5qyyNVRG5BAacsGvJ9Hvizwy8/IICKJuyCJUx35Xax4rHp5fLp2B5NyIFJIDsLsnmnfHt7EdWyaCDxa/n6QiYuMxDqZee6zHG735wa/mbdXZikkatavu+7NpV3WmhVG76jMtbNpV1ZqN2lXpTaN2VUzSqF1VrdmoXVWt2ahd1b4Jo3ZVtWajdtXnZdm0q9o3YdSuqtZs1K5Kbxq161lvWrWrYpJG7aqYpFG7nvWmVbt+t9vjtOs5D1tz+vdW3z3zB6OMUQPV8n1ulMp9qh6SMvmbPhHA2+ospg12Ku8UZTpeyZ1cnbZdPuPRWkbG971vj9cy3+f23BpOxvd9Lpj3933yecuz/r4XzPt/Pq+/jcifWWY1Z5Lry40Hx8tBZb2Xg4LBcezOhzkBiOMgVvGb0QSO8HaM9vb1dLchIJNcLl+obCfq36G4UNAUEvMY1hpyecqB2qFazeInHyES9hqG2xFsd9p1+d5GINYWTxSvkdS44s7IHVpBWllQmW2TU4dciRvprLFed1ItyZw4dVdP90Hug0s+bhsa/UXk8J3GiijqE/10IFp6WyQnlnyUXcQ8jbGGIzQhNt5o1w95PW+jZtdnvdp0sGKlRh2s+yRtOlidc2LUwfqcE5sOVvV0ow5W2tWogxUrNepgVU836mBVTzfqYLVnxaiDVT3dqIP1eWw2Haz2rBh1sKqnG3Ww0q5GHXzWrlYdrFipUQcrVmrUwarOaNTBiiEZdfA5p1v1wfc7jytEfovkckkFvPp18nISh+TKFd77FQnb1FV5bw7ew6MS5TqPkv8/5a43+YxH6yIZ3/e7PV4Xff/bc+tBGd/3v2DeP+DJ5y3P+gdcMO8fePqsgAYgxBSf11FRXSTN7NGjzcNo0S8HinGXCzsJ/3J3/dzISSQoBCRrvb/0T9/1lU4U5eqoF1IAgW9QdUdxMVIElFyj4CQ4r4IWTsV7oj/5LbKcj1Dl8IO7noE0Ec1USRC3qA0E6U4pvzLVPkhLo1RR0nLN4swMHNYq9xq5jPIgv9f2Nn2l0F1RGvLXOn+hhiS3GUiuZwWjHEYioLoppxf3hu4hyO0vJyHzHbzVM/Chr5+3Uf+r/UJGTa3PJbZpasVwjZpa95XaNLU6+8aoqfXZNzZNrXoGjJpa6WCjplYM16ipVc+AUVOrngGjplb7hYyaWvUMGDW1Pu/PpqnVfiGjplY9A0ZNrXSwUVOfdbBVUyuGa9TUiuEaNfVZB1s1tWJbRk191gdWrfGDzuPaFquD57xtQ1IjyY0BDigXyoBwQKm0SWdek+BWqMjG3CO/crAos++XnCcp4/tBt8drrB/8uDFeoi1lfD/4gnn/kCef9w/iM37IBfP+obez/pV0w8ILBPEIUU4I4Uny41cgGkLZImuYiL2NrUnyR07NsrZIbYW49vKe3/XhkpP8lsit2+75yZxXE+01ZaO8z6yfnZUTRx+E7boXstBKiShPnBEFcMeW99nzRnyPW0NnTMQI2fWQtgzSckmyW5JoL0ddShpqgyTTpj8is96Sm3eaurpCxHSkSMRby7LO5eCM2WppaEnCcqiBEJ0Zcj+I+KnLEOIu3+vx1r2iH/Zq3lYvoTS1UZ+rvVpGfa7P0Lbpc8WWjfpc9+Ha9Lk6D8moz/V5SDZ9rvoijPpcaWqjPlds2ajPVV+EUZ+rvgijPld7tYz6XPVFGPW5Pk/Sps/VXi2jPld9EUZ9rjS1UZ+rvclGfa7YslGfK7Zs1OdnTW3V5z/w9jh9ftYaVt3yw87j2hfrjYo3EZhgw6rgHSR6VSc7rBNZku97blTMm6MOLZityH18vLOFr/ESfS7j+2G3x+u1H/64MV6iU2V8P/yCef+IJ5+3POsfccG8f+TpswKSifC0pFM5kQzl4r2JPvetl8PBlnc+Q+QNQm4eBBEX5IrfVY6csagit+57P0LOJJODfyNHBhl021H1HvVWUad+yS2X5Ygjded3NKBD/2IS9peL/sL9WQoElUaECqM6P0gWmSWICvdHJwnsbSEikIOFBYvoGHGWlw0FZOWWti2Vu75lQL7n20JVxsjIXDwq+VekUZczGxgZOjM5CK2cey/qfCuyiRCJMljqb/T5h7+at9WXqL5lo9ZX+tyo9dU+OaPW1+e927S+Yt5Gra/7lm1aX52RZdT6+owsm9ZXvR9Gra/0uVHrK+Zt1Pqq98Oo9VXvh1Hrq31yRq2vej+MWl+fV2rT+mqfnFHrq94Po9ZX+tyo9c/63Kr1FfM2an3FvI1a/6zPrVr/h94ep/XPusWqgX7UeY7kFeItWWjNiAaQzMd34T1vHMqg8yXy8qWNGNkq7L0Q6yGXU2ZxwPDkMx6t/WR8P+r2eO33ox83xks0r4zvR18w7x/z5POWZ/1jLpj3/3Jef6LbZ9rlco0WkUeDBT1QQogdOQyC4EsS3cfMSCYyoBynJtweEo4Q/ULOw3VbyD1sDMz3HAhWuU0Xekl1ruXX7EjOQBCVoLeNMCO/lWpXnoR+UtKd1kd4HHkPCZVEYk8NyD4lFjiyOeFnELdJxMF5Oa1XsDrJJzP/SszBddydiZESHP6QrrSC7M5tkfSQnX4cYRxl8F9IlN2TNoeTNLtnaWr3ZIVMPA5vtP5HvH7eRo+j+ryNvkH1eRt9g9L6Rt+g9igafYO+m8DmGxSLN/oG3edt8w3q3DSjb9Dnptl8g+pvMfoGpfWNvkGxeKNvUP0tRt+g+luMvkHtUTT6BtXfYvQN+jxcm29QexSNvkH1txh9g9L6Rt9w1vpW36BYvNE3KBZv9A1nrW/1DT/y9jjfcNZAVj31Y9XaTnvdeeGPw8uZs6PHgyW1yIOSyIhWiKcgcUJEl3drVZ98dADXuVAi8hmP1pEyvh97e7yO/HGPG+Ml+lnG9+MumPePf/J5y7P+8RfM+389v+dbwzrAWz0he9/kuPCW5PxigreEXsRjxhSLvt4JFF1WOUo4HkR6MvoXco8GTjogSWSPiCc4Rbk4jKTqkdH8N7JXPuRQcmIW+m7rROWaSUCHCGrf7u/RKDOQ4PPRWPzSTeRncrtDy6QUyBqbD8TaKhF+yJ5uAk2oG4qX/xL83Z2woXvXI/KW/5tn20X+HZJgiTGNUN12gg7FBtLl6mWIcnTkDMJacUist/aHfuTreRv9kurhMXoQ1Rdv9CCqL97oQZRvMHoQtT/U6EH0PRo2D6JqBEYPovvibR5EnaVn9CD6LD2bB1E9PEYPonyD0YOoGoHRg6geHqMHUT08Rg+i9ocaPYjq4TF6EH3ess2DqP2hRg+ieniMHkT5BqMHOfsGqwdRNQKjB1E1AqMHOfsGqwdR7NToQc56yqrNfsJ5XETHSTpnFTM3XsUeSG5ttJQSGWrCbfvYJc8WAom0G28lkqjmsYc8yiV3+cn4fsLt8Zr0Jz5ujJdocRnfT7xg3j/pyectz/onXTDvn3xTGom1hLonmewEHPRDZTXvyTsiAmFhw3bvoUj+9/uMvZJ5dv6MX9Z72uUz7vqU0k6twTeRVNiGA2GPsMCGFD6DtbPjdOaBWBFFKXuDScqVVE0uHViX7bUH8SgGj/yXugrSUMzQPuTQwzhribJjHtFAQGrjmJL+hyPgbL651o+eUr7zICTVPeIEHOmCEZG1+Ufd4XT6OBj3NuUsf0wC2nf3smGiU8skx6NB0n/3IB/1at5W76VqF0Y/o/qUjH5G7SMw+hm1j8DoZ5QHMfoZtTfX6Gf0nS82P/PZt8f5Gb2PwOZn1PmKRj+jz1e0+RnVp2T0M8qDGP2Mql0Y/YzqUzL6GdWnZPQzam+u0c+oPiWjn9Hnedv8jNqba/Qzqk/J6GeUBzH6GXV2h9HPqNqF0c+o2oXRz5w9iNXPKKZr9DNnbWbVeT/lPK4mWgHFNMnEe5QGbSeH/R28pof81b3PQhQkBPAQAy/rvsOjyd17qe2afRcyvp9ye7y+/amPG+Mlul7G91MvmPdPe/J5y7P+aRfM+6ertVxJzMXv5HAE6OI/7EFOHIrENvKnSMmwiTTnbacUsQcCJKkJxzIXsks+4+6sIe8jsT0t5F9Hlhe5dKHs6CsKlTOLljgOJACLaOsiE6WbsSElRpBsM+/8DFII8YXQ8CIgNrlZls8nzVXZ+7yT0FA6WaqeY1QJX57IOursRJ2Y7s4aCpHcSFCfzqEje0chHnKsksTumfyYdcfVEDG9pHSpI6GxUNSIadH5442f+ejXz9vo4/T9RDZvpGoqRm+kerGM3kjtuzB6I7XvwuiNlJ8xeiO1L9rojfT9RDZvpGoqRm+k913YvJE6c9PojfSZmzZvpHqxjN5I+RmjN1I1FaM3Ur1YRm+kerGM3kjtizZ6I9WLZfRG+rx4mzdS+6KN3kj1Yhm9kfIzRm+kzmAxeiNVUzF6I1VTMXqjs5+xeqOffHucNzrrPKtm/BnncZGseZElNtS1HznIKZQlk5/ljMbP3wzbFyolIE0IWYtXtKE8ePh8bLik30zG9zNuj9fKP/NxY7zEI8j4fuYF8/5ZTz5vedY/64J5/+zzGEkotbSYJU6Fg9hGrMJ5oFA81ZQR0Gp5lys4pACSYtnkBw7Sq3NH7G9/ZpScQkVmIEKEjZzDCtqixIYmJ6DmdqC/asPPHEjh2HxoS054EqVBHD7u7tIKaDTEwwqIrXDE6YkIRD8SeXCyHmtHXDSEK8OUW2br3tt2kP3kIloczt0+FXIdEYdoWiRaMyuC6qB6dXSc2061Fh1LRk+uuilanO+PFFQwD6Tasb/xRh/zat5WT6j6zYw+S9+lZfNZqtZj9Fmq38zos9Q+FaPPUvtUjD5LeSOjz1J70o0+S9+lZfNZqtZj9Fl6n4rNZ6lzWI0+S5/DavNZqt/M6LOUNzL6LFXrMfos1W9m9Fmq38zos9SedKPP0vee23yWvo/A5rPUnnSjz1L9ZkafpbyR0Weps3SMPkvVeow+S9V6jD7r7I2sPuun3x7ns86a0ao/f456jqRG0iKDzuVlbUZUwKpdLoUiCCG+EALEWph3l40/rIiRQyCRz97my36HR+tuGd/PuT1ed//cx43xEr8h4/u5F8z75z35vOVZ/7wL5v3zz2NEqMttD0Ekg1wDgZGoEXXNe936IsRHCallBfJhRD0shwZA8yMD+H1vu68HPEGo9+uocr4vqolAjuI5Egatjm0Lm48ESRLA1qQVjtUsTobECKvAVN3VoJiX7K7h9xN6KgbQsQg7fqOQHNHqZRGlU0T++8Knb+TxRPDln7cZsrs7m5eC0nCoCbIQ9ikNfqgGWeVUpfiWSiSzbhgmj5ZFi83ssXilZMpaqbq3euo+9tW8rf5Snf1l9Gyqp87o2fS9bzbPpmpQRs+meuqMnk3t6zF6NrWvx+jZlM8yejZ1HoDRs+l732yeTdWgjJ5N7+uxeTZ1Nq/Rs+mzeW2eTfXUGT2b8llGz6ZqUEbPpnrqjJ5N9dQZPZs6D8Do2VRPndGz6fsubJ5NnQdg9Gyqp87o2ZTPMnq2s8+yejZVgzJ6NlWDMno23Wtk82w/+/Y4z3bWn1Yt+wvOzzGXigmj7kUc4E0erBxebKB6OeoakXcI/UBmR8cRfPPaWAN8nQTbJVOXz3i0hpfx/YLb4zX8L3zcGC/xLjK+X3jBvH/Rk8/7F/AZv+iCef9v5/VX5E5uchuKa2YkKZrfT5HQxOVj6yzFsJOVCCzEDKI/9bCtZy/KjKX9tp4NhLERANDDCBrcC8GQ1CZ32lN9Q3ajCwZjYdAb8XYjRDr+ecTF4ONqubtPJeAzItZR9DI5dCd1EboohrkeZx9yZFvqac6IiMLCyB6tib7ajqORsdxxf4YbZW+G0MgdaATZuhiphJNHtubrHI4EUpGB/SBfOj5+1Iwk62gefrPLbzzbx72at9Wrqr5Bo/9TZ7gZ/Z/qGzT6P31Hoc3/qdqY0f+pvkGj/1P7oIz+T+2DMvo/5dmM/k+dxWD0f/qOQpv/U7Uxo//T+6Bs/k+d12z0f/q8Zpv/U32DRv+nPJvR/6namNH/qb5Bo/9TfYNG/6fOYjD6P9U3aPR/+j4Vm/9TZzEY/Z/qGzT6P+XZjP7v7Nms/k/Vxoz+T9XGjP5P9VMZ/d/Pvz3O/521rFUX/+LzHGdrnUjAW1Q68fhgibSD6hyFDZZDHDwOxISTZCdrp+eDH1uJB8IL7i/pjZTx/eLb4/3AL3ncGC/xQTK+X3LBvH/pk89bnvUvvWDev+z0WeEobid/LRSBRw/6OGIgW08USFm725EyclwdMTZEDIwc3I0lyqxGRFl5mfddzY7oiHoUH7YCERprUDsDGdWzhPzMssOSBe5rR7YvUkrqKBTyI+tqbndneEspjlhHig/h8A0RIp2N+5HR9XGjZE6lvJcq99mi66row1BWRVlUzM68u6/HjSgiKHr0LabF9yVnfGyE+7KNlRaKGp+2vHvZMVdTmVvmuyCZkl1m7W/838e/ft5G36tqdkYvqXojjV5SncVn9JKqN9LoJfV9mjYvqWp2Ri+peiONXlLtGzN6SbVvzOgllf8zekl1DobRS+r7NG1eUtXsjF5S7xuzeUl1hrfRS+ozvG1eUvVGGr2k8n9GL6lqdkYvqXojjV5S9UYavaQ6B8PoJVVvpNFL6vt6bF5SnYNh9JKqN9LoJZX/M3pJdUaZ0Uuqmp3RS6qandFLqp4xo5dUtQyjlzzrYqvG/uXn5yjnEnRiqJxycGAng5yAUOpa0m42mUhFCmV+WZ6YTILGxiLliyMdExElRD/cW8j4fvnt8d7iVzxujJd4Khnfr7hg3r/yyectz/pXXjDv//28/uQwc7Imq3wRY7A0OANy84ZSRT4S7occdE40PTAzSMUJQ9mrHPMRPP+Wz7irJZISN9eOKWilA174q1hWinGllMg4nUc8tBBQdIV0ghMpPaPxCBpMp955yTxycDOJ0CYEkPt9Qtg0bJQn3iVJ0FN0RuWX9ZKPOlPDZyG0qTaWftf/uR1ymVSN4VgDCzYxi404jwAeJFqW+ETntMI/RPOTa8lZRCD+ZDoU8Vv3QX3Cq3lbPbTaZ2f0paqWaPSlqv/T6EvVmYpGX6r6P42+VN/9avOlqpZo9KWq/9PoS9U+O6MvVfvsjL5UeUmjL1VnkBh9qb771eZLVS3R6Ev1PjubL1Xnuht9qT7X3eZLVf+n0ZcqL2n0paqWaPSlqv/T6EtV/6fRl6ozSIy+VPV/Gn2pvg/K5kvVGSRGX6r6P42+VHlJoy89e0mrL1W1RKMvVbVEoy89e0mrL/1lt8f50rPGtur1X3WeIyvYyyWnrPG1b2nny0iTdYNsjS8HwvAWhFJQVf6lVy6hRX1HHJXFOr6kx1XG96tuj/cpv/pxY7zEn8n4fvUF8/41Tz5veda/5oJ5/9rzGBPKiVxTsAy8wQdqv5IIyVUOMd7IGfgoEeAHYjVKvPLInyp3BlPX34p8xl2Nc8mZLASa3RfoDcaCcQzZKLi2zDL3cvlxCQGJ3irBGCEo5o0BihQq877GuVhbGJJKVCLq1CMQ6PqSMzG3Qgo+NuzCNuruGJtYU/4x8ZnyZRBreN/jSiDF/mBQYggt5yw+V/TWNjIZbAKcjkiiHiRN6p5YQwbGJ4+CXm1v+dJPfP28jX5c1TiNHlftSzR6XFXjNHpc1eNq9LjqbEyjx1U9rkaPq+8ptnlcVeM0elzV42r0uGpfotHjqn2JRo+rfKnR46rzX4weV99TbPO4qsZp9Lh6X6LN46qz/o0eV5/1b/O4qsfV6HGVLzV6XFXjNHpc1eNq9Liqx9XocdX5L0aPq3pcjR5X3zdm87jq/Bejx1U9rkaPq3yp0eOefanV46oap9Hjqhqn0eOefanV46raj9HjnvW6Vfv/uvNzLD0EN7ZAnNkIlSvxFr10NxKHcuW9oAA1EcEss06Q2OMYLXnqsLwQ+zV9vDK+X3d7vOf59Y8b4yVeT8b36y+Y92948nnLs/4NF8z7N57HSFZAXuATBxEhlUH8w5juyVOaJNqTqQmjuAXqrMUNfhKhSCZEA8z92N629kppVDwtbOjY+aB9rr5IPeSqJtdH5BxkvyVJzPXmsdeI9KO1lygrOtvdedyEOkXgl7UPkcrE+oocEi+Oj64tY5b4mBAKlgTZ3ETx49kR8b3OctfH691ERkCuwtFSyEHU3IFtYbYYUD6sh45oxE2GgfkQB4DPQVG0TuQt7o3H/aRX87Z6e1V7NfplVXs1+mW1j9Pol1Xt1eiXVR+v0S+rM06Nfln18Rr9sr5T2+aXVe3V6JdVH6/RL6t9nEa/rPZxGv2y8rhGv6zO3jH6ZX2nts0vq9qr0S/rfZw2v6zufzD6ZX3/g80vqz5eo19WHtfol1Xt1eiXVR+v0S+rPl6jX1Zn7xj9surjNfplfZ+dzS+rs3eMfln18Rr9svK4Rr989rhWv6xqr0a/rGqvRr989rhWv/xrb4/zy2ftb/URv+k8rp2SV2YksTLwbREtutwPUvnHgcIZMduXo5ORg9v7eHl3cuos676hwjf5jEf7Jxnfb7o93j/95seN8RLfKOP7zRfM+7c8+bzlWf+WC+b9W9UY946oQO/jm73ILhYbGoecWuXs5XjgaEk+g0CTkFC881na9DNR0a2Q5DPu73/f3NFjhC1tCT1Jvog91+JHdBLuRbnGbYsolMbQHa6oRrlVZxDJ8Gx3Z9XiDkLY5fJGEk6pe2CYHvVC7t8x8qhzKroVpR8JTUfEn8vZZEEKwsxpv+9VxncluRMR80Fq5F8Y2j22TXxNRhYuj4FGRLTeG8mhURAPRKmRSNFte+OXP/nVvK2cQNWEjd5b1YSN3lvVhI3eW+17NXpvVRM2em/Vq2z03uqsWqP3Vr3KRu+t73+3eW9VEzZ6b9WrbPTeat+r0Xurfa9G7638stF7q3OPjN5b3/9u896qJmz03nrfq817qztBjN5b3wli896qV9novZVfNnpvVRM2em/Vq2z03qpX2ei91blHRu+tepWN3lvfl2jz3urcI6P3Vr3KRu+t/LLRe5/9stV7q5qw0XurmrDRe6seTqP3/o23x3nvs4+wepLfpr4vHhZSmfEiMxE6gwRUyTQHCQBZg+bHlrSdmWZeCOSXj8w5hLx3HtFLn+qjvZiM77fdHu/FfvvjxniJB5Xx/fYL5v07nnze8qx/xwXz/p3nMaKyUEHEKDIogY14jx/Gw+LKlhyujR4PZXa5POUgQO2LXDznVnwQR/7CmO73CS/0UyMHRMLEQq2VCpBCaU1P+CHKh95xWiR0soUbi/9tBR2Ktkvoldfe27XKb2WI6ILg6y6aFFPwMmok9fBE1zwzIjQevTskOGkdr1FqQd8e485785smCpIwiqg/+N24440Y7LBHKPJ8YBz4+z6LggoVFzGbGGe+zYjWeeO9P+X1vI3MQZ05bPTxqlZt9PGqVm308apWbfTxap+w0cerWrXRx6t+bKOPV2cOG3286sc2+njlvY0+XtWqjT5e9WMbfbzaJ2z08WqfsNHHK+9t9PHqzCmjj1e1aqOPV7Vqo4/X+4RtPl7dE2P08fqeGJuPV/3YRh+vvLfRx6tatdHHq35so49X/dhGH6/OnDL6eNWPbfTx+j5Om49XZ04Zfbzqxzb6eOW9jT5encVq9PGqVm308apWbfTxqk/V6ON/6+1xPv7sSaz+5nednyOvBFW2lALSnLTPkku8Y01OQvKBAMsLdYTgE5+zRJwXRB+LhQQeZb3LZzza18n4ftft8b7udz9ujJf4WRnf775g3r/nyectz/r3XDDv/+O8/kiGqGHRoQRmpBKaaOFr8LCy42Ir+04sXGHNJDaQEnskGx2z7uSf2t727iCPO0XGCgmrc2B/QpPrkClZ+zBIfrXvo+HT+KRMyCMtIvoHfrbPsuP67mrorVO9xiEgS0iOxBR0xY4WJh+hP6JPSBrWqdvHNokgTDUjogmzXtLTXQ1ddBuKcS3pIY/TdzQzEhIPT8KGYODsN+JLIV0SuGW/CQ6syo2wlWp6L298/Ke+ft5GfqF6zo1MQJ0dbWQCqoZuZAKqhm5kAqqGbmQCal+1kQmoGrqRCaiecyMTUGdHG5mA6jk3MgHl441MQNXQjUxA9ZwbmYDaV21kAmpftZEJKB9vZALqvC8jE1A1dCMTUDV0IxPQ+6ptTEDdHWRkAvruIBsTUD3nRiagfLyRCagaupEJqJ5zIxNQPedGJqDO+zIyAdVzbmQC+r5XGxNQ530ZmYDqOTcyAeXjjUzg7OOtTEDV0I1MQNXQjUxA9eIamcDvvD2OCZz9jdUr/V49R14tnh3/Koir6h2Lh5w/idYIPNQFKRo6gM+pFASpCK5AGiduR6LULp/xaI8o4/u9t8d7xN/3uDFe4o1lfL/vgnn//ief9+/lM37/BfP+P8/rD1lL3IhzGzFIy3wphHWWL4p8STN9TwS01klkB/onEa2mnD9GfmyInre/Twpn0ybpQiJODvjYFhgi8ncLWAOkXMc3xIZOKXKEA5kC/IBhHXLCYb47aw2FgMJZjGHGo24LtlB6C3LOYUxytbCsup2AIRF8W2QBYpnkGXQ0kma7YwKU/yeZp2YmmrbENzazJMFGdOR7ONABkn9R4vhRwEU4kL1tF3uEc0hvmMCnvZq3lYXofeg2vqD66o18QZ0BbuQLqrZv5Auqtm/kC6q2b+QLah+6kS+o2r6RL6i+eiNfUGeAG/mC6qs38gXFBIx8QdX2jXxB9dUb+YLah27kC2ofupEvKCZg5AvqrDUjX1C1fSNfULV9I1/Q+9BtfEHdJ2XkC/o+KRtfUH31Rr6gmICRL6javpEvqL56I19QffVGvqDOWjPyBdVXb+QL+j5hG19QZ60Z+YLqqzfyBcUEjHzhzASsfEHV9o18QdX2jXxB9Rsb+YKqeRr5wtkrWX3XH1DvRCokbCayid9CEDqc0oGy3BZiQA57RqsfoSwSOtowlYiUkKrkLt0JL/uZH+03ZXx/4PZ4v/kHHzfGS3y2jO8PXjDvP/Tk85Zn/YcumPcfPo9xthwxp0RthxyWtzwfrRN4eLWRAniylndJOjjJ9pLD9uRyJ9nxd76Qs9yH3LeHfwt5oaoCWXomDyFwIuiwFhhElLo0EuA0ys54MbZy8EVphIh+xxc2bFNfsI2E2iOdYuMrH4RaQIDEWkhtEdGTmCXKJrltdrQTin8guWe84wsjjkA6PZiLUA8+K8BTUMB9IsSDQ842kpz0E7WM1pf7BpkP5mIkUMQbvvDpr+dt5Cpq74CRVeh9+zZWofYOGFmFOsvdyCpUz4GRVaieAyOrUD0HRlah9u0bWYXqOTCyCrV3wMgq1FnuRlah9g4YWYXiC0ZWoXoOjKxC7R0wsgq1b9/IKtS+fSOrUHzByCrUOXdGVqF6DoysQvUcGFmF3rdvYxXqjjEjq9B3jNlYhdo7YGQVii8YWYXqOTCyCrV3wMgq1N4BI6tQ59wZWYXaO2BkFfq+ahurUOfcGVmF2jtgZBWKLxhZxZkvWFmF6jkwsgrVc2BkFWe+YGUVqhZrZBVn32X1cH/k1Rz5+6w2HufBU5yB1EOU2OX955vfUfSNvI3qcAcSmvVPspUDzzaJvfIZj/auMr4/cnu8d/2jjxvjJZ5dxvdHL5j3H3vyecuz/mMXzPuP387++iBdrIG/rC1P0V7JkTfIgZVPJYQVFjO5jQTEckZouEW6dwW9WP3y8hnvejc+hzwlrkT0WRVxkEileZKyE/GarEpYxqP2Kefcs36wcXVOYh1horu7/RGhNxEFGTVaFhkdl3iQUT1KDShBHq+O2Cc9DQXTx9cyW6k9ktGhAGj9O1aBegwD4yO3aQxC5cDuEKDnRjze91oz9n+vO7YBx0y8X3GAJA8Cot9IFW9YxTtfzdvKaNQZg0buofZHGLmHPufAxj3U/ggj91Bn8hu5h+qFMHIP1Qth5B6qF8LIPdQ5B0buoXohjNxD7Y8wcg91Jr+Re6j9EUbuoViFkXuoXggj91D7I4zcQ51zYOQe6pwDI/dQrMLIPdQZg0buoXohjNxD9UIYuYc+58DGPdS9c0buoe+ds3EPtT/CyD0UqzByD9ULYeQean+EkXuo/RFG7qHOGDRyD7U/wsg99H3oNu6hzhg0cg+1P8LIPRSrMHKPM6uwcg/VC2HkHqoXwsg9zqzCyj3+8O1x3OPs4ax+8E+cnyO/F0eAlotkqzWdbILnywqdFR2S3Dmely+YjVqCRztPQgZuEf9E7Ckvd7Q92gfL+P7E7fE++E8+boyX+H8Z35+8YN5/6snnLc/6T10w7z99HmPyG6ExEmkO6UpKPclRhm1LuLIBRAglTf4okSZGPDAMMIUm2QeZSrCVz7g735Eoi7B3YUEJJg6HiJjENxBjWBvEauwj4Q9BiebCFxL0F7GUhITvXsfduRDY/UJwwHUWpOySSJM7+IB8iQ4B0wTf+BnkIDZawphrq4iMHQXRnu+5h4RdJLvbpwCNytdGeqn8BhJH4uvCZjP8idtIa3V0ncyYdI+MQVW94R5f8u652HiP4h5GhqLOdzQyFLUHxMhQ9LkQNoai9oAYGYq6W8HIUFSPhpGhqB4NI0NRPRpGhqLOhTAyFNWjYWQoag+IkaGouxWMDEXtATEyFMU9jAxF9WgYGYraA2JkKOpcCCNDUedCGBmK4h5GhqLOdzQyFNWjYWQoqkfDyFD0uRA2hqLuIjQyFH0XoY2hqD0gRoaiuIeRoageDSNDUXtAjAxF7QExMhR1vqORoag9IEaGoriHkaGo8x2NDEXtATEyFMU9jAzlzD2sDEX1aBgZiurRMDIU1RtvZCh//PY4hnL2g1Zv+WdULOQbIVY4h8zBUOXdMYk8qJh35rUoL2MFMRqZB17Kxog74mQg7ChC+0vO1pTx/Znb4z31n33cGC9hCTK+P3vBvP/ck89bnvWfu2De/9d5/SWUHg4jiSJNccOaEZpcDrKnBbexsMg9oRbrapW4vR+4aOTYvhCHyC75jDuGgsTFc5FxUKlyKIeDPtYu3p/0SBge5AsCJ0GtIC4YPKEskXaRn2TjdbfPZe65Co4g7OCIxPCvDfOI6SH1uzLIHWgQucACF7dHOCf6DdOGBvZp3Z+jsbu1CNQBXLQTRAEeO2orClTBczdkY0dPbIec4CnhGUqTS4ykO77q9lbvyJe6e942dvQpt8fxGMVQjDxGna1p5DFqn4uRx+hzNGw8Ru1zMfIYdUeGkceo3hEjj1G9I0Yeo3pHjDxGnaNh5DGqd8TIY9Q+FyOPUXdkGHmM2udi5DGKoRh5jOodMfIYtc/FyGPUORpGHqPO0TDyGMVQjDxGna1p5DGqd8TIY1TviJHH6HM0bDxG3U9p5DH6fkobj1H7XIw8RjEUI49RvSNGHqP2uRh5jNrnYuQx6mxNI49R+1yMPEYxFCOPUWdrGnmM2udi5DGKoRh5zJmhWHmM6h0x8hjVO2LkMWeGYuUxf/r2OB5z9pZWn/rnz3MMJM/JomkZXTSI4bxliHrUrlymQKguonoX3ytRd8cv8M6LNYTHVJ6+fMaj/bmM78/fHu/P/8LjxngJl5Dx/YUL5v0Xn3ze8qz/4gXz/ks35WNfbvMh/WSP0WAZp11yEKFu7zNVMdgYFowsPpn0LQF0vYSbibB++ztLGV2oWxdFhGbAb+A/chsL40SuRljKER+MnMzbC8NrRMyGyhRxuB/lbi8P8kf20WVC/cTeTNx+QX0vxFA/Fnqi49ABQDCLKLeXTkfMzgh8MmQ+7s4d8XJGKczJieguTS4nRkvi6YixGyISTVlIVSRjOYyEVARxYPz8CWCGiPSGx3zp1/M2cih1rqmR7bzz9ji2o3iMke2oc02NbEft5TGyHX3uiI3tqL08Rraj7joxsh3V02JkO6qnxch2VE+Lke2oc0eMbEf1tBjZjtrLY2Q76q4TI9tRe3mMbEfxGCPbUT0tRraj9vIY2Y46d8TIdtS5I0a2o3iMke2oc02NbEf1tBjZjuppMbIdfe6Ije2oO0uNbEffWWpjO2ovj5HtKB5jZDuqp8XIdtReHiPbUXt5jGxHnWtqZDtqL4+R7SgeY2Q76lxTI9tRe3mMbEfxGCPbOfMYK9tRPS1GtqN6WoxsR+1xMLIdVes3sp2zT7V63r+s1tAipxMQQqipHlUSLbEART7ljeC31FjLRCYNhr1jRxhwQWmg1pubUz7j0V5fxveXb4/3+n/lcWO8hHHI+P7KBfP+q08+b3nWf/WCef/f5/UXyKtuYVBIMZ509nJyrKh2CeOBF59gP0Tckk4dXiqh+EEroJiBKXzbe2yRBtt4MRY7ZnDH2DXfxYqR3pA0iQXOnxBIybgYmETQOljbaCsMtFvxrtcGYeNxZ9jynlIWL01+WCOgkPjMTWCPOCUmQZAlSSFH5Wzn6Ehafquv2Q6+vb5M7EBMexDWCqlhfxkWcpFMhAw/dk9wJLmCPLB5MBHyEFoy4wfesJ3PuJu3jWkptmPkROpMWSMn+ozb4ziRYjtGTqTOlDVyIrVfyciJ9DktNk6k9isZOZG6s8bIiVSvjZETqV4bIydSvTZGTqTOaTFyItVrY+REar+SkROpO2uMnEjtVzJyIsV2jJxI9doYOZHar2TkROqcFiMnUue0GDmRYjtGTqTOlDVyItVrY+REqtfGyIn0OS02TqTusTVyIn2PrY0Tqf1KRk6k2I6RE6leGyMnUvuVjJxI7VcyciJ1pqyRE6n9SkZOpNiOkROpM2WNnEjtVzJyIsV2jJzozHasnEj12hg5keq1MXKiM9uxcqK/dHscJzp7Xqt//mvn5yiZRmbFuy52LSJZZ6g++cC3TExzh8TXQ/JPF6dQeAeZbxa1vV6u2Hg4N5Dx/bXb47nBX3/cGC/hJTK+v37BvP/Gk89bnvXfuGDef/P8ngeydESdIW1wZoRLpC1KHnkkW5NQzV0CKxFxX2GbVW7kmYRsNAaupojNuL97KIjwP9w2cS2o8eqiO0QKxCDXg3uCNIYRXgQDIIb5DVua0CuJFAz5cfc9QAhQ3H7Ix+4k7oIljlLFz+JjovCsEsg3ASRTk6i0GSBFBCl+JMbjjhMBk5Y0NvGFBQZbk/z00ZHu/A2WOUE9k5j4Agg5AJ4qjhstQdR01b1195B7/byNfExxIiNzUpzIyJzUeb5G5hRvj2NOihMZmZM6z9fInNSeLCNz0ufa2JiT2pNlZE7q7iEjc1I9QEbmpHqAjMxJ9QAZmZM618bInFQPkJE5qT1ZRuak7h4yMie1J8vInBQnMjIn1QNkZE5qT5aROalzbYzMSZ1rY2ROihMZmZM6z9fInFQPkJE5qR4gI3PS59rYmJO629jInPTdxjbmpPZkGZmT4kRG5qR6gIzMSe3JMjIntSfLyJzUeb5G5qT2ZBmZk+JERuakzvM1Mie1J8vInBQnMjIndSeLkTmpHiAjc1I9QEbmpPaqGJmT6o0wMqezf7Z68b91fo5+BskNB5b2RZuhUyLfxMYvWHUGh9MjYDD8hZ5FJw+oFAsbmY4WLVk+49EMQsb3t26PZxB/+3FjvIS9yPj+9gXz/jtPPu+/xWf8nQvm/XfP7zm5gB+eCedJcEdyOLKsrH1X9xHnwuh6SXCEgVpJq6njNZD52DVfvhDmtJNcET3YORILrijHJoCpzE0SI2QDFwoYQWWXLNq/SQIgWCMsMBT73VnKiO+KQk57Qe5sexWeg6OoKO6+O1zfwEOkY8jJPpjyyNhhUA5NuhAv7Y45YQ2ZIfkL0NFmwBD0KYd5oRQxpB0hsRoZNgGYJNaMTtQtyxfJvwTuN8zJv563kbVp5mTjV4o5GfmVYk5GfqXOUjbyq3p7HL9SzMnIr9RZykZ+pfadGfmVPgfIxq/UvjMjv1J3SBn5lepNMvIr1Ztk5FeqN8nIr9Q5QEZ+pXqTjPxK7Tsz8it1h5SRX6l9Z0Z+pZiTkV+p3iQjv1L7zoz8Sp0DZORX6hwgI79SzMnIr9RZykZ+pXqTjPxK9SYZ+ZU+B8jGr9R910Z+pe+7tvErte/MyK8UczLyK9WbZORXat+ZkV+pfWdGfqXOUjbyK7XvzMivFHMy8it1lrKRX6l9Z0Z+pZiTkV+dmZOVX6neJCO/Ur1JRn51Zk5WfvU3b4/jV2cvbvX1f+88rjEwfJ10i/yXKJfGnkm0jKhjJUmoruALDnkHyI2TdYWjIf4i6QqWRz7j0TxDxvf3bo/nGX//cWO8hOPI+P7+BfP+B08+b3nW/+CCef8/5/ccVkM6XbzamdzbnRCXnHBn6MtM1Bzo2iDXg4NtD7kanV/O4t6JfLjpl3m/5lf8siAZORK2HCALSeqSZ3UTuHZf0Y+4UIHBYkCI0WiasKHR+edDFOkdvyLBizKKYhP4KwQ5NBaBdiHg8HzirI624cZBFfxOkNlAvZC5cQVEunt+FV78EDCkYko66Y1410VdEPP3bYlmRKtuBXuAoMX77xFz0cU4I07e8Kvwat5WbqfuAjOyMM2vbCxM8SsjC1P8ysjC1DnWRhb2mbfHsTDFr4wsTJ1jbWRham+dkYXpc5NsLEztrTOyMHUXmJGFqZ4pIwtTPVNGFqZ6powsTJ2bZGRhqmfKyMLU3jojC1N3gRlZmNpbZ2Rhil8ZWZjqmTKyMLW3zsjC1LlJRhamzk0ysjDFr4wsTJ1jbWRhqmfKyMJUz5SRhelzk2wsTN2BbmRh+g50GwtTe+uMLEzxKyMLUz1TRham9tYZWZjaW2dkYeocayMLU3vrjCxM8SsjC1PnWBtZmNpbZ2Rhil8ZWdiZX1lZmOqZMrIw1TNlZGFnfmVlYX/39jgWdvb1VkbwD89zDHxOjmEQjtzMeI6dVd5R5PylyqtSRM8Q7BGBWZw4IaeTzsiOkXf15WzlR7MRGd8/vD2ejfyjx43xEiYk4/tHF8z7Hz/5vOVZ/+ML5v1PzmNc0oA4oRc48EWMQDeQ0wn1G8Ib6oAjJgYfPSOmkHZNkFTd9+kqIXbs8hl3vVwTJyc6F0chwGfFhUFHqc1EusQfLrzrgkRUAq/HLPB7g0R5sgK5yt/tH3RAo4pqQI6iivlLEV+RQEs+YbAzQ2wofH7DwACB6Hz3BzQHtRwySvaOhW3AHAw94Z0YRzRGGY6EVoooEhE02yQRJdQvHh/I5Cd4G5ZC0uZ3tfKGhcVX87YyQMXCjFxN3elm5Gqahdm4mmJhRq6mWJiRq6kzxI1c7bNuj+NqioUZuZo6Q9zI1dT+QSNX0+dM2bia2j9o5GrqTjcjV1O9XEaupnq5jFxN9XIZuZo6Z8rI1VQvl5Grqf2DRq6m7nQzcjW1f9DI1RQLM3I11ctl5Gpq/6CRq6lzpoxcTZ0zZeRqioUZuZo6Q9zI1VQvl5GrqV4uI1fT50zZuNqZhVm5mmJhRq6m9g8auZpiYUaupnq5jFxN7R80cjW1f9DI1dQZ4kaupvYPGrmaYmFGrqbOEDdyNbV/0MjVFAszcrUzC7NyNdXLZeRqqpfLyNXOLMzK1VSPi5GrnRmBlTf80/NzXBPxm5HZXRYgecrtbvIwsyeobZOXDxdeCNo9MnEUMcJor4XUjYsNL9unHs1ZZHz/9PZ4zvLPHjfGS/iSjO+fXTDvf/7k85Zn/c8vmPf/e15/4noC4hlx3WprxFIMLSkQbYk+Kihd/ExH2wuOEZM3wDFQmsbKmO4L7zGbAC6cGD+PwEqJwIWxa8huInyTv41PLwe/d0cxF4+RqR7ERO7Pdz1m+JwpkgiWxGdAu8AY5UCi7bJjUoI3ut/tSGxUReEn+IKQBUHGC4S7u5uPhIqkJ24CMEB1u6sTGOMrw8HLx5DcOopwAX4K1Zckr+NHgyQOEvgbrpZezdvKEz/l9jhGp7iakdGpu/mMjE5zNRujU1zNyOgUVzMyOnV+u5HRffbtcYxOcTUjo1PntxsZndojaWR0+lwuG6NTeySNjE7dzWdkdKrHzMjoVI+ZkdGpHjMjo1PnchkZneoxMzI6tUfSyOjU3XxGRqf2SBoZneJqRkanesyMjE7tkTQyOnUul5HRqXO5jIxOcTUjo1PntxsZneoxMzI61WNmZHT6XC4boztzNSujU1zNyOjUHkkjo1NczcjoVI+ZkdGpPZJGRqf2SBoZnTq/3cjo1B5JI6NTXM3I6NT57UZGp/ZIGhmd4mpGRnfmalZGp3rMjIxO9ZgZGd2Zq1kZ3T+5PY7RnXmDlV38i/O48CvIb7JWS6UNdBcyxRHDRp98NXwrSIHpeFfWAnLgqHjbUH1jydFHe5HPeDSzkfH9i9vjmc2/fNwYL2FVMr5/ecG8/9WTz1ue9b+6YN7/+jxGUiZ5CwGL0Btig1fLfh/SBEbabmLQE9EKA9wiXKBLUyhGWlATAuKFRd/3voVIlsGgpBg32TbtJJKG9nIMoGMkRA4kJz6PtFcJHmS9vRwyEPxqu+t9i4fcTYGwhdOQh0hJiOgKbQLhVFxj33LqUbao4lZ2aUKVc/8n8GoTUfCa0ZFpEhkmHuWQJIYlJnjiHRkSNOeA5VRwiPBDqFKTy1Qbf0AmySRNyM4bRpdfzdvKJlXvm5H3vfP2ON6nGJ2R96k7Fo28TzM6G+9TjM7I+xSjM/I+dXa+kfd9zu1xvE8xOiPvU2fnG3mf2gdq5H36HDMb71P7QI28T92xaOR9qvfNyPtU75uR96neNyPvU+eYGXmf6n0z8j61D9TI+9Qdi0bep/aBGnmfYnRG3qd634y8T+0DNfI+dY6Zkfepc8yMvE8xOiPvU2fnG3mf6n0z8j7V+2bkffocMxvvOzM6K+9TjM7I+9Q+UCPvU4zOyPtU75uR96l9oEbep/aBGnmfOjvfyPvUPlAj71OMzsj71Nn5Rt6n9oEaeZ9idEbep+6eM/I+1ftm5H2q983I+9T+OCPvUz1BRt53ZhdWDvJvzs9xJ6KROTMmZ9uOBeM48MZERjxwSuKn+KCBrhM+ErOoYPkF/MIDQtjlMx7Nf2R8/+b2eP7zbx83xku4l4zv314w73/35POWZ/3vLpj3vz+/5wSG2IWpBPh2JcYHv/O5M+PuRGaNBvggy3eENOpNjoIj4mM88J9pe9nTfcf7WnKtC9MgWQ2shcsvSecoayKSgweCeLl7Ez0g/HBHFeP/SSuOxBbcfU8eEb0BD0n7m/C4KXtz8WOJUQn4cAwUIQEgKbPE4RBiSbLnFDff3V1PHiYWSYHJJvvjHLN3GRuE/u2Yv22RexBtWNN0bHKFAYwMVsWXhEnlm6pveF95PW8j57zryTOwQ9WTZ2SHn3F7HDtUvM/IDtVdmUZ2qHmfjR0q3mdkh4r3GdmhurfAyA4/9/Y4dqh4n5EdqnsLjOxQ7XU1skN97puNHaq9rkZ2qO7KNLJD1ZNnZIeqJ8/IDlVPnpEdqnPfjOxQ9eQZ2aHa62pkh+quTCM7VHtdjexQ8T4jO1Q9eUZ2qPa6GtmhOvfNyA7VuW9Gdqh4n5EdqnsLjOxQ9eQZ2aHqyTOyQ33um40dnnmflR0q3mdkh2qvq5EdKt5nZIeqJ8/IDtVeVyM7VHtdjexQ3VtgZIdqr6uRHSreZ2SH6t4CIztUe12N7FDxPiM7VHcIGtmh6skzskPVk2dkh2feZ2WH//r2OHZ45iBWpvIfzs9R3BBYECOcoCkwBv6y6PyIYggovMlX4ET/4n0HBgErUeNEevBF88fyGY9mSTK+/3B7PEv6j48b4yUMTcb3Hy+Y93968nnLs/5PF8z7P5/fcxLOsQjwOyGLaNWdiwQY0h/JT1TSvmS1L+LqBusiT7NgCyYdRU5sXfIZr9mh65Ajx7KH5AkH2UdMlSyZ97khwbGbGCKJEI61jIlw8D1Ctfxf4V/HXa9gA1DhkDc51E6oX8g434O/BkQkyZWMqRxxIHU3ae4j/wgGlTP/Domqd+yQL+w4PEaGdDBLgnKgt/kG4D6kCWCMrPUMh9mjY/4EIaTkgQ5Gspfq37DD+mreVmaqewVtHPKuV9DAIVWvoJFDxtvjOKRih0YOqe48NXJIzQ5tHFKxQyOHVOzQyCHVnRFGDvl5t8dxSMUOjRxS3Rlh5JBqP6+RQ+pz8mwcUu3nNXJIdeepkUOqXkEjh1S9gkYOqXoFjRxSnZNn5JCqV9DIIdV+XiOHVHeeGjmk2s9r5JCKHRo5pOoVNHJItZ/XyCHVOXlGDqnOyTNySMUOjRxS3Rlh5JCqV9DIIVWvoJFD6nPybBzyzA6tHFKxQyOHVPt5jRxSsUMjh1S9gkYOqfbzGjmk2s9r5JDqzggjh1T7eY0cUrFDI4dUd0YYOaTaz2vkkIodGjnkmR1aOaTqFTRySNUraOSQap+jkUP++9vjOOSZqVj5zH/R4yKADr6UgsicJNDBmz4yRqHGgzWOmUj9ZZrE1cmizCMN/BJhhxC2y2c8mkvJ+P7L7fFc6r8+boyX8DgZ33+9YN7/7cnnLc/6v10w7//v/J6vFz5AHCb2ieoMc4jowuixpAlca8h1rngHgewE29D5ETyy7G7GH8hn3J0rSMphsSycPXRwbcgz0jrQCy5FlBAmMVz2SFkEOhGbcIGIEQIJkME133FISdlhl45FAjt6GYQDSdt860hYsgVmFx6AsEb3d4wWdlBUJ/JnYYD3+/s6kFPoGABOkVMJsvBS0tYW3CLgNXQmhAQO5btvZSeSDiTZIayFL+J461zB7fXzNvJXxSGNTFP3MNqY5l0Po4Fpqh5GI9Ost8cxTcUhjUxT3V1rZJqaQ9qYpuKQRqapOKSRaar7OoxM88whrUxTcUgj01T3dRiZptqzbGSa+lxBG9NUe5aNTFPdXWtkmqqH0cg0VQ+jkWmqHkYj01TnChqZpuphNDJNtWfZyDTV3bVGpqn2LBuZpuKQRqapehiNTFPtWTYyTXWuoJFpqnMFjUxTcUgj01T3dRiZpuphNDJN1cNoZJr6XEEb0zxzSCvTVBzSyDTVnmUj01Qc0sg0VQ+jkWmqPctGpqn2LBuZprqvw8g01Z5lI9NUHNLINNV9HUamqfYsG5mm4pBGpnnmkFamqXoYjUxT9TAameaZQ1qZ5n++PY5pnvmMlfUIPHprXAQoQkQQ6e5D4g0rHXOAC0dcIiZYhJgqggVfXES14kEW4WgRS5AA7ZLeypcPfMfjGdc73vHcbE/G944L5v0uTz5v+cB3uWDe7/oO5aWCuCLcYEMqkbf8IiyzYHnhHRAT3ZDQOQ0atkfICIIeIwOhFMvgD/mMu33ZKwjRw7HiNbC2oQ+cEdgQWR1nSgcrCKUMniGYYsg2fnsnGnr8IJrojmmyoPCoZMSjS3BBzQNo0LN8vDg3eBkxZknCJ083TIvAEuIZMbHitsId01yQI8wnchHGlHEcQiuR7sgioAAuMvRE0u1wP9kETiZyhPVFIkdb9/WGabZX87ay3E+5PY6PKqZp5KO6t9LGR+96Kw18VPVWGvnoZ94ex0cV0zTyUXUHsZGPaqZp46OKaRr5qGKaRj6q7kox8tEz07TyUcU0jXxU3ZVi5KNqX7aRj+pzGG18VO3LNvJRdQexkY+q3kojH1W9lUY+qnorjXxUncNo5KOqt9LIR9W+bCMfVXcQG/mo2pdt5KOKaRr5qOqtNPJRtS/byEfVOYxGPqrOYTTyUcU0jXxU3ZVi5KOqt9LIR1VvpZGP6nMYbXz0zDStfFQxTSMfVfuyjXxUMU0jH1W9lUY+qvZlG/mo2pdt5KPqrhQjH1X7so18VDFNIx9Vd6UY+ajal23ko4ppGvnomWla+ajqrTTyUdVbaeSjZ6Zp5aOq58zIR8+sx8qNvsiZlwWJqOTIihGKoo6wBAgP7FHgLSNSHJh+zG1DGkek46wbQnIR6qboa/mMR/MyGd8XuYCXfdEn54Qyvi96wbzf7cnnLc/63S6Y9xc789FUlqjriF4kCAnXyBMdSYBH1EaHn5F/QBoZG8I1Y4kdwnzDWnm5ukY+4/4u6bSww6yNjk8j8eEuyBCChoKYRkaFqOAPEKlTZDGWZiNpkzL4O+7unhpX+YuNP+7ojAFTAFQRFw6sKzEtYxDI5sTPPCsZhP8mYQ72R+ivtay7vecvvhY8EosX15eFfTTpKBXhgREXi7qI6x4eQuI4iINIe5AhhlPE2hs++mVezdvKhdW5lUbWeuajVtaq+KiRteqeTxtrvev5NLBW1fNpZK2fdXsca1V81Mha1V3SRtaq+aiNtSo+amStio8aWau6p8bIWs981MpaFR81slZ1T42Rtaq950bWqs+ttLFWtffcyFrVXdJG1qp6Po2sVfV8Glmr6vk0slZ1bqWRtaqeTyNrVXvPjaxV3SVtZK1q77mRtSo+amStqufTyFrV3nMja1XnVhpZqzq30shaFR81slZ1T42RtaqeTyNrVT2fRtaqz620sdYzH7WyVsVHjaxV7T03slbFR42sVfV8Glmr2ntuZK1q77mRtap7aoysVe09N7JWxUeNrFXdU2NkrWrvuZG1Kj5qZK1nPmplrarn08haVc+nkbWe+aiVtZ75qJW1frEHstZ3PzMo3j8MjsQvn+TLDRPcitlNsg138BUierdchCzwahAbcG9oJjePhpASC/Nw9ibje/cL2Nt7PDlzlPG9xwXz/uIPnvcdc0T7E9exSZ7gw1tx4OFQWhOVzHijrOZDFG5nEngfiTsVglBQ+mjsebfPfGaWCXiMcBjxV2XveH25oz6XksEZzLCEvGPtCPvRo2/EHnaQCuu19bvzLv3yoYMbQgm4RBJNxNEQhQl8KHvyGhJzQRMkOmJaMpgi8+3t5BzWvvvCmKOXs27dCJIcsTY8DrIdUggJPlEMCfiID8l4W4SZl/t+BlqbhMf/Mj99N7Z/OWV3ioCMsFYJd4TTOrPQJZhul3CdZk27JFYMPpF/J1tiUTJ5T/Vk5ij9pXwOcSRKwhFXCOzBNqC7nLTlhhdg0jDtpK/ZJuq6rABr4/GofeYhkfBfJCoskTUP5wnUYLbAKPEJSCgJVRvfBJ4ZBctXyD+PEjsTDufMHEFZEEAAKB6gCgPDzHU+k5hz9CTeDC8PUaopDyQsLhoOwCfhDvFqU/dk4nRJWD4VXDu2eOeJLtzJhoDBSHVUvbhbEjasg+BLiI8S6IKcH8ILpO7KIVPkVAMuFmQKQCtARVRpgaRNshrRmbQ1iNI4hIzuL5lMiaiDdgzcu2KOQiVJgIm/AfoVQ/ByYiv2wPPGE2zx+XLNPD4Lrs0vQMUAAEAv4PNxKOaIQJqIFwpcHdKYYWNkDSzafqB5sWF89oGHgppk3hOQHCCBYcsLzVPXzPHlevgJ3kRjk2tddcDEikjcoD9oyY3/NsmzDSuD6p+tkdsGSLl7cqm6K8cnx9u985YhPllZAxAYYVeRtwRd1QkA1Or4muFGlAio0g2WvfjHQMbb9N3YFfLRQWJ8bdQfFnUEn1H2vNaVGoBbwG0SJ8wJZrSzchPZk5yJEs486KTuxp4sbN588jyuuCTCI6h1Y8kAICAsBM/SEGYsbd7gTjXFCywXnz8lXCrmyDuPnK8vMSOJoYAiDR4ByxA2BMcCcTepfmBYGhmfX4mXwEws4I+P+q4cMibh5OW8i0WoiDUylMXjwmWCDhO/IcMcD5mBm4OvkiW/YcB4jl73ZEIU8bKEBrQfvoBvF74owmmTcLTk5jD+Cr6AMLkzex4kfxQLL54sLdWTCTjlq3dVvqq8weF8EEgByElEj0ENghWZ5gv9QuRjQXAHLGyefAF86Z5MxAMaGmXJChBPJg39MC80zN6LvC8EN/wBzCMLmSSqzwNhD45Z2xHUPnMgahGXSZUIXUx8XUN4uZyMwmwyjkOer2O5yysvKn1kT7Ac6P44VU8mkxOGhdGWxnssIVElLaQOrx2v7eTfKB/+KTGML9UJQyGdVjlZiHcuauZI8kD4wMN3QeSISDyLFOxeah+UlALSGaxPuYRVLUaCF57AU2CxrUTFHDfALTlbXAQM25GPeOUPkBcvJe8CyxQWCfYUqraOMYLgcidrXhamOu+SJ44mpjBCulny5/xGdC0RDH8GagKmYcM35DJqEz3HM4Gm7bJGscdL3Y3NDDJz4qvPVL8a4Bd5StREMVepfQ2YMchezsfeUNodQwsqBKQNOU166X3mwClSMy6c+Ixl72Ip+EG/YbGlTAGi76R2dD0cqmeqWIHw3eBNQKdeVU+mEG38J1+ZJ8eyflkZVOgglbIi+c4QJ0JhmCyFAqqnvLF1Se0Kt72i2meOWqk8Fn5sC5+/lGbkhS18seShnf8hReOGB+aCmlMlMJKPCPqCSY+gmKMoE35I1qCTREPm74Ocw5If+xalcAkNQE1ncnb18A8SETwfJt/cKKonEyXTZMMIEMpLiZaSDgIFR0D1khyP1iPekjciIKJsAsfk9isQFoU8EJlijrA8KPU2ErGPsMN/CQeFsA2vDO2OcrY3sQiKA9+HqqHIyEK81cdLwnPqvMslqISYQrkGmUM0gflTeOv81Y3UlilKpkRS4I0+qK7xImY+cBc2SvFC92RuByCQEvfwuzhkT6aHvvAOdOi89wi4zORRhlSiipP1Rf0VKymMjZqt6slEKqGQ+G2L0kSWlxp6tSjlEb5wYdSZ8ZpJHizUlRCEacW+syxh0wgqdd4lcWAXRzjDPjaJzrG+0C/i6ME6xiVSSwyHlzODcT8Qbp4U4+WrQCE5tc+conOi/gyIhq+QppqEPRIbEfjoi/+EGHDoYxFlEGhqMphSlirhy0OrNHMcG/yD+sUExzmqjbxrgBL06k5A9mhCrH72wPODd4qoAdmiEL1tFE3ABoo5xkK+E/SwtYAHFWEOmEX57AMhIOG+zQFxQDGxoijjkh/x0fy3Te50UOddwnATpIvK+JTBQY17Z1lS6dgYBlU/QjMBjsQtrIVq19r5FzG3w+j1eZe8E2ALHjLvJVFnR52wikj1kNpAfAGzIg55QwkjZEvgGcsV10OJhSyzqbty+HmwzUHqxPJTMpZy7EI7EWRXR4Twojnhh7KwqYAgrTM/XGFqCKFVlmKOUqPyLwVAXvL4YuEj3wNj5OtfAuqw7VS/oC+81qhEIFgGS/OLpV9J3Y0tuRB61AWCZnm/RcVnCnQNSkYxkie2JF9UDPghBWvoIIW8wtomaC91Vw7fRpZIysMHivFiEuWIAItYm1F/vOQAasiVp6zlMFPwi8J3T5SjShmr6skERAKCeSZuk2oStf9ZeEnRkagtVgUBCK5GCmbBdIFzYNoXsQrI471XzFGuEIAooxixJ+IXqHiRCCE5LBlUNwve7ayxhSjhC8c2khnQUZ0fQV6pnkz4mVDNCRMRrk9OoAq6CwlHSBG7WEAIVhwWYhcXLDXqmkFFPGbQo9pnDsZANAr6zlR6yLP8RqmaTigSKgJKWIIAQ5gX0m10sX67hMhO6EE06LtyEqSdlAi3JyXywOT/EMGAaqwbWV47L5TEGaoWYucQcdKCA1/ir07FHFF/UjuubgLQIP4MkS+5yoZgTD41BpQrhJ2vTWpEjocolLxLfw+hIqt95jtrmZxMJaphgYlZlOWxphNWQ71Man45SAG6CM0UZ5mhfhsWkAcJalXMkaoR4BPSENBqDr29SXUe0Af9GVluy3jBVgy8SAm2ADLJRsS5JZfPHmqfeZYuGZaKjI/iGwSfPMgaSYLwWfG8UH0hw5CUlP6qlDJ5rUX5oAJzUcxxAfawN3g6Cl4TKYz7wm2RHcB5hyBHqgnUyH0pVKKl20BqclSBiRmkCHVnMCohYxGpCjlkUiICsWhhfDzRKdEUtE6mEgSZiBZCQSU4bhTeqKGHrnoyC689MUKsJ6PLQj2RY6wPnAz5lT8A/7I6SZYDQURttsjqQYIQM2s4M0fKrlL3RHEwPMSJFGop+W24EGofrHUkEPEaa0NqlC4RL9mOP8C9wyD1/lsp5IgpmHAjsSrAEum+AjA2IfOUYpG4kzjD4+Rd5Xc28cs4FHJU9Y9kjl/iPC4noi1W56mdOOrOhHFMIsXb9XKtCrGbtEgEJbvwdTTiYBkEmymNcpu/pL9TxvclLmBv7/nkzFHG954XzPu9rmaO+yQUBRIgOQ9FQBwSgk3mqbJ0EUUUc6WPGLcoFTdwBHIMqEYMkdLG3f3cEBGyWhaWiX0DZxHKRL9KiwyKYiwSByQkOZg/dh8fQKHsWBvqRwTTXZ8jpQpfQf1SnA+pYpcPCq9UHsTj8RZnqgcNN7lJ6ZrkS7AiTJED5JadfX5hzNGVIp155CnKZF66IhClpEQPqMBwJDkQNFW5Yxy1xXdxVNlinj2yoPLbp+pzRC7mJD1PoFTpzAC/QV1JOHylaJ0xMdfwTcGNL6aFXC4OC4tNedGtd6r3hS91yl5+YF0/MMCoVAQrDg+TIT2SiBDYmyv8ZX6Y0E+RBJ3wouey6nNEj1ALoSBPiiEBwfCyNKe8OACiAQW5A30jeosyKG57e6kOpu3ATjTis9oHjobBKkGnN3mDKQbJmaNg0F1aYREYTIknTHkrUxYnPyb+h5c7SCGrOnU/NxqYr+QA/cB50AeYQdwG4LIvUglBKvIApLi38f2TdimQMjkyDZJ8ZhcUc8wAFeQWuR81Lt28fYi+jZKZCfNyez2PDBeJI4hC9cANvEWUcze+TnW2pcM98zNBinZrl6aiitgeWGPJ7kGMdgG8Aed4tafU96SIsyHtQWqYCHW2ZSgYjh1sQEmXrxQYskvNGpUSo5Tnk7RvUDSXHogkZBqnxRqtEbkDQlbMkdwcxTRL0Q0rx6stTat88fgZpGCUI5uFYW+ihClBsb4YMa8YacrHqJkjk4Fgg+d5KYbUeHm5JA1W36WpGWrA3xK2f5Cpm5RgqUrwf0AmvLln5kgdDzIp/b0pg55ZxrtU9nnjSM0lLhG+MAYcDfXU0gUpoK6pWks7JL5GMUcIPMVnXiAyP0Q6BSZSWYOwQkwrIiaJKCwQoyAlEHIe1dmJbYV7UaVUZ1tKueMgrpDopDdoE3iVGcOBnEQopUGlMkkRFO9WKSQ6EjilD6RSqpRe1D5wohzqBW6DhksobDfRMXAb9ALRq0voxA9IEyWsO1CZxBlJDy/PAP+omCNFaaYFyipgLuYHYJKDfgHlqSLDwKBUfaicsGSQOh1jL1JFmrSgiYxY7wMfvIo8GcJskOvWAsSXZcNKIkzvIUM/0KOu80MoVWr/CFhp1YT4saCGYo4vO0Ow4A6LBrNBo1KCALzFzUuxlocGXGpobFmrUGovRXwKBtJruDRzxOvh8d0LNcPp7NIRIRpYIFCBfg5iLHUVgTYYhV0KtGjRJp2mQTps1T5wtDYPBWAF/WDNSG84xQhebgogoFqWRRZCipQW/8Y0k8BCHBcrGAmpmOMmlhhLAG2hTsJCcwliEAGCvPe4pyR9KkXeD54e8RcQG8Txtg5K2cP3Uu/9To2hIQuH0CRpxBW3snu+GhwGqZKIJ+Uv9DPrFWMPjt+AVxTgeXHU2ZZBdKW0logxXOBgKtheTq+OgdThJY126boH7MOuDiIGTmrHExLCNkSo2gfuEYIFD4BWx5khv8Hj0B+QhAfiYIc97JHs/mKCmkB9pGEXzY9kjZvqc4QbDCIRi4jwBPWnzI7fwV2QxEgpZE7E8yYwBU6CcveSQcHj8BCGlTVznEBSlpssOWHRBaNC1iezkbU7A+jSQYTlzawxUvuQGjpMgLVd4CNqHzhgDHguTV+Ab3IYxSgn6UracjH58t4KysMTJjGVvFqUWfCaHctLxFBnWxKDd0AKiYBvgi+OZIlCFkcNg05VPOcmhVdkD3nTi/soL0uBSg9fxpk5BnmhhaLwpcjWKkxaxMqh+VbksyYPVnquiKS8Fjgl8P4udgiqSEjxRd3PvUgLSXy0yA2pzYFLSBfVU0njPZ9Ad1Y6Ugrq0RdvHCVPiq3CBfjiFHN0mFYBn/5FCIAWceyy6wSVKe0dUhQQrAsagbhjdKkhDCkhFV42SE1SfY4k1mPxF8herER+FehXyh6sXaqYLG0sdSh4YyTloNxJBVB2nxGqyTNlU8yRyixBEsQfpHxHLUH66si1JDeGQkmCzM4vZG1g5CUpONngwyMa0qAU1D5wOfyHMjHrXhTYJMk28axTtl8gPQa0jMITEYSfgbp6IvZLyzvUfeDy9f3coDFZFnjLnXKntEBRK0eO7P5IwgtAeVKXlbITuaCPIvtt0HK7k60k6mxLJ0UQ3qiE25bvnaeFDKlFjnxHa7BcCBmb9H8gL6WE31GckHyENeSuKeaIzeQLk6oGle0D1UQNAFQutRb+opcSfAZzHegVAqPsr+B7PMBS0nndltoHTp16ikALWZwG/AaoC1WhJnUQVNZkRUl477LZRgSKkDPQJG+XlC6c2geOMhaviwQJyH2+ll3qnegvxA5Mj1/De8q7gIaW+qwIpk34GGoPCJ8Vc+TLIi4IRQwSWUlnkbcAPtkoBBCP4Rh8Baj9jfVHDW7hBKAuCOXAa6Lu2CFvA7R56WUpU6zhVYaR809FGJJoQDvkoSakSo7I520kcqDwgvSywvLUPvCapSlLlA4wqGXZQoEWI1uKSOp8XdJIOKSmwxPmIfJNupceWghxbln1OQ5QM6vu81Mp+FsaeKnBoSUO8gV1GdYKNdMoBXFpW5TSKumFDAASakn1OcIksRUJG0WNA/ZcgvTogUURarzBCxRLJf+FdRDiKOmjuhHvvP2F8NHV2ZZRQiiKHMoCSSU58EudxB+UZOWVrIBjySxL3kG8yy4Nv5N64pTsoZgjL0HFPwwkIWwGzitVG5KI9LqSQaBrifJcKVneaKpK1L83noWIvMh3ofscvWDQKq89un4fUrgjYFKIA6/yb9YdGZUA0wixwHrpOUXSkUNJNnBMxRxZFnwMrhb+xOqW2xWQfYNPFvdWqDwGosKSxvJKwoI9Ibz4Oy/t0iPoPkc8I1ZB6mjUIKnPMB7pwmbSSXaGZNmTyJqiPJGLtL3z5R38PKWLyGRVn2MmlxHgArCIKuUQZM2C2VLIXbbqSufLoD4q2YewRp7d5eXGEroCrJuKOXo+gLiMI6UES1GOdNhkE5OI8ySsa5esOkSPdOx+kF4YMUeEOFzkppgj02byDHxFuS9CSrFD2ig2qqCN3LgD1wCEBH2QI6JQWshluVNX45tV93NLhVKgAeFjB05NV2RfJlgc7QYIBlNjtgCWxNpIUYCihGy+zA2eiQHIeh+4dAhEOQtO2nGxV7yswSfsy3jpHRR3xpoYYmBEncFcpjBgaUWIR9oUc5QCON6MgCnlGx+lkEzOjKBWCn6J8teBm3HC/UTzd4wH4VZqx5scTKf6HKkaENBx9jxqQCLhk+cvAiQQYkUjEZ1Z1Cwvx5NlXX5BU8hEM6Q9qD5HQh+F2SHaEhbLK49ZX0W6UjYn++p4hFQ1efUyNTr8Bl9Bkp15yAsCRX0kc3xvfRYhKFzsNMxadhjxva8dmcvbKw09vKdUF1HzLG8xChOC7FlPglpYey/H8T2avcn43vsC9vY+T84cZXzvc8G83/dq5mjs4ZWe1nMvppd9u6BuSkdNqsrSA/5y1zZQfn/pIfDYzybdJlQTpPsb0YZJm1hw8tELUz9zVjKgNIigrajlkkxluwFqcohXRQdMkgEClSokNcUgTQ5N9ijKqZeyhaVMeRff94Ln8n7nOQMZSRtIJsocXTbCFdk+uEQ6MDgMZI3SZIHE91Kpk85DghFpS3ry3XbF+yjje78L5v3+T74OZXzvf8G8P+DidWita71eh7iaJHvUF84VI47MahSrwXf8IhYbyqSJrkI3CvmUuiiO2ZOgWfP4yvh6HXrnXfV8GxH+K2xXdnbhp4rUv5EJPok0IZqIOJakCEhA/ZJhD3jo0a9ahx/4DtUDJTvnpCRC/QIf3pcQGC8EB9Aum7VaP6Jse0WvIB5ky9shCITQ4a95H2V8H3jBvD/oydehjO+DLpj3B1+dD41a7y4fVsGssrpzn7IPiVcTuyI9RbJ5U+pPZAUqcpSHMEuFOj9eDTu6rRWa93frEJoCMcR9VxcQ6+QYaYzAFPDhTeoECXBONarKOSkVySzXS85KLQ3hvdxV6/BDlAbAWuCqIS2OskXoByFhziqnS3vZ2Cbta6DfRQwDM5Z9LGyCMJeMiwuXvI8yvg+5YN4f+uTrUMb3oRfM+8OeXJeK9vmAB+pSieEf/EBdKu/ih13wXD5c5cP+sge4UQQmOACU5YABYRgCuGRXBNKgSR2MUq/srUQxTOp6VM2hAfWS91HG9+EXzPsjnnwdyvg+4oJ5f+ST69LX69CqS1+vQ6suvWodfpTK2bJvBOjNVxJeNiWNPYDvYGcvzXDU2dekzpWlfoFa2DJOMksr755lR9QV76OM76MumPdHP/k6lPF99AXz/pgn16V3+dCoS+/WoVGXXrUOP1bFikB5fZMzfmrMgsAprWz8hilVNczhIQ0czZMI+UrrNpZPiyI9cJ4y6nEJp5HxfewF8/64J1+HMr6Pu2DeH//kulS0z0c+UJdKDP+YB+pSeRc//oLn8glKly7Xj0qFi2oy382imCwlRL60Jrewyzlyshf42OcMsb/UlScle77oKN34V7yPMr5PuGDen/jk61DG94kXzPuTnlyXvl6HVl36eh1adelV6/CTz3P2slmJTL2Pyje0O6kq9wAdlTP+0qIqnV/OeGiL6HNM2b29epWNXY3yfLjifZTxffIF8/6UJ1+HMr5PuWDen/rkuvQuHxp16d06NOrSq9bhp53HOOW0TOkqOdwM/khdziKQkyGb3/iapA1+D9JzE4cc/XhsG+Qmyda3kKkoXvE+yvg+7YJ5f/qTr0MZ36dfMO93Xr0OD1LTEeWQEPRfcS63FpuTvUJ9d31vLL4iKXJIx4g097qyzdhHytL0XET7fJJaNxW51eQk5zqPEkWfhUEG9F0O7HUtk9zQtNK9KFtiy6Te5iCL/MdjhJc4rmJPmrGFGSbFgdbbIe1aec4mJ/jJIRbRh5dtPgzw5cBBaQQrfg45C2AbLcm7+M53PP55v8vtsc/lXW7//V/veJv/fP7zN//6/wGXZrVykF4DAA==',
  debug_symbols:
    '3ZzBahtLEEX/RWsv+tb09Mz4Vx6PINtyEAjJyHIgmPx7FONRjGVaiPSi6izHajUq5hZcjuG8Lh5Wdy/fv623j7vnxe1/r4vN7n55WO+2x6fXRXr70/PTcvvn6fmw3B8Wt/14s1htHxa3SunXzeJxvVktbot+3ZydHIfyfnScutNR67442g3T+9Gs8veofXHUks3XWurGv4fzF4dzSTZfXNL08fD/NwsB5tPp4tLp03wGn6+D5zPD318Pn6/En68//Ybcj5/nG+D7N8LzOcHzKXyBoTcYASpMPaL0DqNMjyigxdQjCqgx9YgSekw1ooAiU48ooMlUI2qEJlNFFYAmU42oEWBMNaKEJlONaHY5oCXNA5q6f4qozyZz1YD1iPpsMtcNWI2ozybTMKI+m0zDiPpsMu0i2vlsMu0i2vlsMu0i2vlsMg0j6rPJHGM3D5gHqw84TuNw+g0ffoTGtwEzfUCfTeaaAafU9e+Hp5TPBvTZZPrSzQP2U/q8Vj7LScPU+SwnDQf0WU7arVX2WU6qa5V99o12qcs++0bDAeP3jQtrlQOuVfwKcSF1PitEwwHj940La+Wzb9TXKn6FqKeu91khGg4Yv2/U16r32Teqa9XTkUWf6QPSkUUfEFn0dGTR05FFT0cWJSCyKHRkUejIotCRRckB14qOLAodWRQ6sigBkUWhI4uBjiwGOrIYAiKLgY4shkwfkI4shoDIYqAji4GOLAY6shgDIouRjixGOrIY6chizAHXio4sRjqyGOnIYgyILEY6spjoyGKiI4spILKY6MhiyvQB6chiCogsJjqymOjIYqIji+ME8fZKiQ4tlOjUQomOLZRyxNWigwslOrlQoqMLpYDsQokOL+TUS9pyQjq+kFMzaX21nNpGWwYv4yekIww5FY5eWC06xJBTi2jLCfEYw6lHtL5aTt2gDYPnVA7ackI8xnCqB72wWniM4dT52XJCPMZwav28sFp4jOFU5dlyQjzGcCrzrK8WXtApvKFTeEWnIjo6hZd0Cm/pFF7TqYieTuFFncKbOoVXdSqiq1N4Wafwtk7hdZ2K6OsUXtgpvLFTeGWnIjo7hZd2Cm/tFF7bqYjeTuHFncKbO4VXdyqiu1N4eafw9k7h9Z2K6O8UXuApvMFTeIWnIjo8hZd4Cm/xFF7jqYgeT+FFnsKbPIVXeSqiy1N4mafwNk/hdZ6K6PMUXugpvNFTeKWnIjo9hZd6Cm/1FF7rqYheT+HFnsKbPYVXeyqi21N4uafwdk/h9Z6K6PcUXvApvOFTeMWnRVR8Gl7xaXjFp+EVn5ZyxNWiYwzDKz4Nr/i0iIpPwys+Da/4NLzi0yIqPg2v+DS84tPwik+LqPg0vOLT8IpPwys+LaLi0/CKT8MrPg2v+LSIik/DKz4Nr/g0vOLTIio+Da/4NLzi0/CKT4uo+DS84tPwik/DKz4touLT8IpPwys+Da/4tIiKT8MrPg2v+DS84tMiKj4Nr/g0vOLT8IpPi6j4NLzi0/CKT8MrPi2i4tPwik/DKz4Nr/i0iIpPwys+Da/4NLzi0yIqPs2n4rNTnq/t1I/113J8hfPh3I86m9BlmbhuwpJsvrik6WxCl83jygl1urh05+8w41Pqsnk0TanL5tE0pS5rStOUuqwpTVPqsqa0TKlPeWjLlPqUh7ZMqU95aNOUAjrNhZRmfEoJnaaeUkCnuZBSQKe5kFJCp6mnFNBp6in1qSVtmVKfDtOWKfXpMG2aUgKnqac041MK6DQXUkrgNPWUEjpNPaU+O01X5v+fdN0w/FtKfXaaqyasp9SnHfXKCasp9WlHbZlSn3bUpin12WlapjTjU+qz07RMqc9O0yqlx4e7/XqzWX//ttndLw/r3fb5+NXjn38s9+vl3Wb1/vj4sr3/8Onh59P8yfz9p/3ufvXwsl/9uents+P1vwE=',
  file_map: {
    '18': {
      source:
        'pub mod bn254;\nuse crate::{runtime::is_unconstrained, static_assert};\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        static_assert(\n            BIT_SIZE < modulus_num_bits() as u32,\n            "BIT_SIZE must be less than modulus_num_bits",\n        );\n        self.__assert_max_bit_size(BIT_SIZE);\n    }\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_le_bits)]\n    fn _to_le_bits<let N: u32>(self: Self) -> [u1; N] {}\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_be_bits)]\n    fn _to_be_bits<let N: u32>(self: Self) -> [u1; N] {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_le_bits\n        let bits = self._to_le_bits();\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[N - 1 - i] != p[N - 1 - i]) {\n                        assert(p[N - 1 - i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_be_bits\n        let bits = self._to_be_bits();\n\n        if !is_unconstrained() {\n            // Ensure that the decomposition does not overflow the modulus\n            let p = modulus_be_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[i] != p[i]) {\n                        assert(p[i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the \'self\',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            "N must be less than or equal to modulus_le_bytes().len()",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the \'self\',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            "N must be less than or equal to modulus_le_bytes().len()",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    // docs:start:to_le_radix\n    pub fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, "radix must be greater than 1");\n            static_assert(radix <= 256, "radix must be less than or equal to 256");\n            static_assert(radix & (radix - 1) == 0, "radix must be a power of 2");\n        }\n        self.__to_le_radix(radix)\n    }\n    // docs:end:to_le_radix\n\n    // docs:start:to_be_radix\n    pub fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            crate::assert_constant(radix);\n        }\n        self.__to_be_radix(radix)\n    }\n    // docs:end:to_be_radix\n\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // `_radix` must be less than 256\n    #[builtin(to_be_radix)]\n    fn __to_be_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            "N must be less than or equal to modulus_le_bytes().len()",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n/// An unconstrained only built in to efficiently compare fields.\n#[builtin(field_less_than)]\nunconstrained fn __field_less_than(x: Field, y: Field) -> bool {}\n\npub(crate) unconstrained fn field_less_than(x: Field, y: Field) -> bool {\n    __field_less_than(x, y)\n}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unconstrained context\n        unsafe {\n            field_less_than(x, y)\n        }\n    } else {\n        let x_bytes: [u8; 32] = x.to_le_bytes();\n        let y_bytes: [u8; 32] = y.to_le_bytes();\n        let mut x_is_lt = false;\n        let mut done = false;\n        for i in 0..32 {\n            if (!done) {\n                let x_byte = x_bytes[32 - 1 - i] as u8;\n                let y_byte = y_bytes[32 - 1 - i] as u8;\n                let bytes_match = x_byte == y_byte;\n                if !bytes_match {\n                    x_is_lt = x_byte < y_byte;\n                    done = true;\n                }\n            }\n        }\n        x_is_lt\n    }\n}\n\nmod tests {\n    use crate::{panic::panic, runtime};\n    use super::field_less_than;\n\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_bytes();\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_bytes();\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        // 259, in base 256, big endian, is [1, 3].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 1, 3]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        // 259, in base 256, little endian, is [3, 1].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bytes, [3, 1, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_radix_example\n\n    #[test(should_fail_with = "radix must be greater than 1")]\n    fn test_to_le_radix_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(f"radix must be greater than 1");\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be greater than 2\n    //#[test]\n    //fn test_to_le_radix_brillig_1() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(1);\n    //        crate::println(out);\n    //        let expected = [0; 8];\n    //        assert(out == expected, "unexpected result");\n    //    }\n    //}\n\n    #[test(should_fail_with = "radix must be a power of 2")]\n    fn test_to_le_radix_3() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(3);\n        } else {\n            panic(f"radix must be a power of 2");\n        }\n    }\n\n    #[test]\n    fn test_to_le_radix_brillig_3() {\n        // this test should only fail in constrained mode\n        if runtime::is_unconstrained() {\n            let field = 1;\n            let out: [u8; 8] = field.to_le_radix(3);\n            let mut expected = [0; 8];\n            expected[0] = 1;\n            assert(out == expected, "unexpected result");\n        }\n    }\n\n    #[test(should_fail_with = "radix must be less than or equal to 256")]\n    fn test_to_le_radix_512() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(512);\n        } else {\n            panic(f"radix must be less than or equal to 256")\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be less than 512\n    //#[test]\n    //fn test_to_le_radix_brillig_512() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(512);\n    //        let mut expected = [0; 8];\n    //        expected[0] = 1;\n    //        assert(out == expected, "unexpected result");\n    //    }\n    //}\n\n    #[test]\n    unconstrained fn test_field_less_than() {\n        assert(field_less_than(0, 1));\n        assert(field_less_than(0, 0x100));\n        assert(field_less_than(0x100, 0 - 1));\n        assert(!field_less_than(0 - 1, 0));\n    }\n}\n',
      path: 'std/field/mod.nr',
    },
    '22': {
      source:
        '// Instantiations of Poseidon permutation for the prime field of the same order as BN254\nuse crate::hash::poseidon::bn254::consts;\nuse crate::hash::poseidon::permute;\n\n#[field(bn254)]\npub fn x5_2(mut state: [Field; 2]) -> [Field; 2] {\n    state = permute(consts::x5_2_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_3(mut state: [Field; 3]) -> [Field; 3] {\n    state = permute(consts::x5_3_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_4(mut state: [Field; 4]) -> [Field; 4] {\n    state = permute(consts::x5_4_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_5(mut state: [Field; 5]) -> [Field; 5] {\n    state = permute(consts::x5_5_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_6(mut state: [Field; 6]) -> [Field; 6] {\n    state = permute(consts::x5_6_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_7(mut state: [Field; 7]) -> [Field; 7] {\n    state = permute(consts::x5_7_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_8(mut state: [Field; 8]) -> [Field; 8] {\n    state = permute(consts::x5_8_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_9(mut state: [Field; 9]) -> [Field; 9] {\n    state = permute(consts::x5_9_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_10(mut state: [Field; 10]) -> [Field; 10] {\n    state = permute(consts::x5_10_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_11(mut state: [Field; 11]) -> [Field; 11] {\n    state = permute(consts::x5_11_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_12(mut state: [Field; 12]) -> [Field; 12] {\n    state = permute(consts::x5_12_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_13(mut state: [Field; 13]) -> [Field; 13] {\n    state = permute(consts::x5_13_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_14(mut state: [Field; 14]) -> [Field; 14] {\n    state = permute(consts::x5_14_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_15(mut state: [Field; 15]) -> [Field; 15] {\n    state = permute(consts::x5_15_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_16(mut state: [Field; 16]) -> [Field; 16] {\n    state = permute(consts::x5_16_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_17(mut state: [Field; 17]) -> [Field; 17] {\n    state = permute(consts::x5_17_config(), state);\n\n    state\n}\n',
      path: 'std/hash/poseidon/bn254/perm.nr',
    },
    '23': {
      source:
        "// Instantiations of Poseidon constants, permutations and sponge for prime field of the same order as BN254\npub mod perm;\npub mod consts;\n\nuse crate::hash::poseidon::absorb;\n\n// Variable-length Poseidon-128 sponge as suggested in second bullet point of section 3 of https://eprint.iacr.org/2019/458.pdf\n#[field(bn254)]\npub fn sponge<let N: u32>(msg: [Field; N]) -> Field {\n    absorb(consts::x5_5_config(), [0; 5], 4, 1, msg)[1]\n}\n\n// Various instances of the Poseidon hash function\n// Consistent with Circom's implementation\n#[no_predicates]\npub fn hash_1(input: [Field; 1]) -> Field {\n    let mut state = [0; 2];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_2(state)[0]\n}\n\n#[no_predicates]\npub fn hash_2(input: [Field; 2]) -> Field {\n    let mut state = [0; 3];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_3(state)[0]\n}\n\n#[no_predicates]\npub fn hash_3(input: [Field; 3]) -> Field {\n    let mut state = [0; 4];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_4(state)[0]\n}\n\n#[no_predicates]\npub fn hash_4(input: [Field; 4]) -> Field {\n    let mut state = [0; 5];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_5(state)[0]\n}\n\n#[no_predicates]\npub fn hash_5(input: [Field; 5]) -> Field {\n    let mut state = [0; 6];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_6(state)[0]\n}\n\n#[no_predicates]\npub fn hash_6(input: [Field; 6]) -> Field {\n    let mut state = [0; 7];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_7(state)[0]\n}\n\n#[no_predicates]\npub fn hash_7(input: [Field; 7]) -> Field {\n    let mut state = [0; 8];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_8(state)[0]\n}\n\n#[no_predicates]\npub fn hash_8(input: [Field; 8]) -> Field {\n    let mut state = [0; 9];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_9(state)[0]\n}\n\n#[no_predicates]\npub fn hash_9(input: [Field; 9]) -> Field {\n    let mut state = [0; 10];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_10(state)[0]\n}\n\n#[no_predicates]\npub fn hash_10(input: [Field; 10]) -> Field {\n    let mut state = [0; 11];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_11(state)[0]\n}\n\n#[no_predicates]\npub fn hash_11(input: [Field; 11]) -> Field {\n    let mut state = [0; 12];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_12(state)[0]\n}\n\n#[no_predicates]\npub fn hash_12(input: [Field; 12]) -> Field {\n    let mut state = [0; 13];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_13(state)[0]\n}\n\n#[no_predicates]\npub fn hash_13(input: [Field; 13]) -> Field {\n    let mut state = [0; 14];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_14(state)[0]\n}\n\n#[no_predicates]\npub fn hash_14(input: [Field; 14]) -> Field {\n    let mut state = [0; 15];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_15(state)[0]\n}\n\n#[no_predicates]\npub fn hash_15(input: [Field; 15]) -> Field {\n    let mut state = [0; 16];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_16(state)[0]\n}\n\n#[no_predicates]\npub fn hash_16(input: [Field; 16]) -> Field {\n    let mut state = [0; 17];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_17(state)[0]\n}\n",
      path: 'std/hash/poseidon/bn254.nr',
    },
    '24': {
      source:
        'pub mod bn254; // Instantiations of Poseidon for prime field of the same order as BN254\nuse crate::default::Default;\nuse crate::hash::Hasher;\n\n// A config struct defining the parameters of the Poseidon instance to use.\n//\n// A thorough writeup of this method (along with an unoptimized method) can be found at: https://spec.filecoin.io/algorithms/crypto/poseidon/\npub struct PoseidonConfig<let T: u32, let N: u32, let X: u32> {\n    // State width, should be equal to `T`\n    t: Field,\n    // Number of full rounds. should be even\n    rf: u8,\n    // Number of partial rounds\n    rp: u8,\n    // S-box power; depends on the underlying field\n    alpha: Field,\n    // The round constants for the\n    round_constants: [Field; N],\n    // The MDS matrix for the Poseidon instance\n    mds: [[Field; T]; T],\n    // An MDS matrix which also applies a basis transformation which allows\n    // sparse matrices to be used for the partial rounds.\n    //\n    // This should be applied instead of `mds` in the final full round.\n    presparse_mds: [[Field; T]; T],\n    // A set of sparse matrices used for MDS mixing for the partial rounds.\n    sparse_mds: [Field; X],\n}\n\npub fn config<let T: u32, let N: u32, let X: u32>(\n    t: Field,\n    rf: u8,\n    rp: u8,\n    alpha: Field,\n    round_constants: [Field; N],\n    mds: [[Field; T]; T],\n    presparse_mds: [[Field; T]; T],\n    sparse_mds: [Field; X],\n) -> PoseidonConfig<T, N, X> {\n    // Input checks\n    assert_eq(rf & 1, 0);\n    assert_eq((t as u8) * rf + rp, N as u8);\n    assert_eq(t, T as Field);\n    assert(alpha != 0);\n\n    PoseidonConfig { t, rf, rp, alpha, round_constants, mds, presparse_mds, sparse_mds }\n}\n\npub fn permute<let T: u32, let N: u32, let X: u32>(\n    pos_conf: PoseidonConfig<T, N, X>,\n    mut state: [Field; T],\n) -> [Field; T] {\n    let PoseidonConfig { t, rf, rp, alpha, round_constants, mds, presparse_mds, sparse_mds } =\n        pos_conf;\n\n    for i in 0..state.len() {\n        state[i] += round_constants[i];\n    }\n\n    for _r in 0..rf / 2 - 1 {\n        state = sigma(state);\n        for i in 0..T {\n            state[i] += round_constants[T * (_r + 1) as u32 + i];\n        }\n        state = apply_matrix(mds, state);\n    }\n\n    state = sigma(state);\n    for i in 0..T {\n        state[i] += round_constants[T * (rf / 2) as u32 + i];\n    }\n    state = apply_matrix(presparse_mds, state);\n\n    for i in 0..T {\n        crate::as_witness(state[i]);\n    }\n\n    for _r in 0..rp {\n        state[0] = state[0].pow_32(alpha);\n        state[0] += round_constants[(rf / 2 + 1) as u32 * T + _r as u32];\n        crate::as_witness(state[0]);\n        {\n            let mut newState0 = 0;\n            for j in 0..T {\n                newState0 += sparse_mds[(T * 2 - 1) * _r as u32 + j as u32] * state[j];\n            }\n            for k in 1..T {\n                state[k] += state[0] * sparse_mds[(t * 2 - 1) as u32 * _r as u32 + T + k - 1];\n            }\n            state[0] = newState0;\n\n            if (_r & 1 == 0) {\n                for k in 1..T {\n                    crate::as_witness(state[k]);\n                }\n            }\n        }\n    }\n\n    for _r in 0..rf / 2 - 1 {\n        state = sigma(state);\n        for i in 0..state.len() {\n            state[i] += round_constants[(rf / 2 + 1) as u32 * T + rp as u32 + (_r as u32) * T + i];\n        }\n        state = apply_matrix(mds, state);\n    }\n\n    state = sigma(state);\n    state = apply_matrix(mds, state);\n\n    state\n}\n\n// Performs matrix multiplication on a vector\nfn apply_matrix<let N: u32>(matrix: [[Field; N]; N], vec: [Field; N]) -> [Field; N] {\n    let mut out = [0; N];\n\n    for i in 0..N {\n        for j in 0..N {\n            out[i] += vec[j] * matrix[j][i];\n        }\n    }\n\n    out\n}\n\n// Corresponding absorption.\nfn absorb<let T: u32, let N: u32, let X: u32, let O: u32>(\n    pos_conf: PoseidonConfig<T, N, X>,\n    // Initial state; usually [0; O]\n    mut state: [Field; T],\n    rate: Field,\n    capacity: Field,\n    msg: [Field; O], // Arbitrary length message\n) -> [Field; T] {\n    assert_eq(pos_conf.t, rate + capacity);\n\n    let mut i = 0;\n\n    for k in 0..msg.len() {\n        // Add current block to state\n        state[capacity + i] += msg[k];\n        i = i + 1;\n        // Enough to absorb\n        if i == rate {\n            state = permute(pos_conf, state);\n            i = 0;\n        }\n    }\n    // If we have one more block to permute\n    if i != 0 {\n        state = permute(pos_conf, state);\n    }\n\n    state\n}\n\nfn sigma<let O: u32>(x: [Field; O]) -> [Field; O] {\n    let mut y = x;\n    for i in 0..O {\n        let t = y[i];\n        let tt = t * t;\n        let tttt = tt * tt;\n        y[i] *= tttt;\n    }\n    y\n}\n\npub struct PoseidonHasher {\n    _state: [Field],\n}\n\nimpl Hasher for PoseidonHasher {\n    #[field(bn254)]\n    fn finish(self) -> Field {\n        let mut result = 0;\n        let len = self._state.len();\n        assert(len < 16);\n        if len == 1 {\n            result = bn254::hash_1([self._state[0]]);\n        }\n        if len == 2 {\n            result = bn254::hash_2([self._state[0], self._state[1]]);\n        }\n        if len == 3 {\n            result = bn254::hash_3([self._state[0], self._state[1], self._state[2]]);\n        }\n        if len == 4 {\n            result = bn254::hash_4([self._state[0], self._state[1], self._state[2], self._state[3]]);\n        }\n        if len == 5 {\n            result = bn254::hash_5([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n            ]);\n        }\n        if len == 6 {\n            result = bn254::hash_6([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n                self._state[5],\n            ]);\n        }\n        if len == 7 {\n            result = bn254::hash_7([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n                self._state[5],\n                self._state[6],\n            ]);\n        }\n        if len == 8 {\n            result = bn254::hash_8([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n                self._state[5],\n                self._state[6],\n                self._state[7],\n            ]);\n        }\n        if len == 9 {\n            result = bn254::hash_9([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n                self._state[5],\n                self._state[6],\n                self._state[7],\n                self._state[8],\n            ]);\n        }\n        if len == 10 {\n            result = bn254::hash_10([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n                self._state[5],\n                self._state[6],\n                self._state[7],\n                self._state[8],\n                self._state[9],\n            ]);\n        }\n        if len == 11 {\n            result = bn254::hash_11([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n                self._state[5],\n                self._state[6],\n                self._state[7],\n                self._state[8],\n                self._state[9],\n                self._state[10],\n            ]);\n        }\n        if len == 12 {\n            result = bn254::hash_12([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n                self._state[5],\n                self._state[6],\n                self._state[7],\n                self._state[8],\n                self._state[9],\n                self._state[10],\n                self._state[11],\n            ]);\n        }\n        if len == 13 {\n            result = bn254::hash_13([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n                self._state[5],\n                self._state[6],\n                self._state[7],\n                self._state[8],\n                self._state[9],\n                self._state[10],\n                self._state[11],\n                self._state[12],\n            ]);\n        }\n        if len == 14 {\n            result = bn254::hash_14([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n                self._state[5],\n                self._state[6],\n                self._state[7],\n                self._state[8],\n                self._state[9],\n                self._state[10],\n                self._state[11],\n                self._state[12],\n                self._state[13],\n            ]);\n        }\n        if len == 15 {\n            result = bn254::hash_15([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n                self._state[5],\n                self._state[6],\n                self._state[7],\n                self._state[8],\n                self._state[9],\n                self._state[10],\n                self._state[11],\n                self._state[12],\n                self._state[13],\n                self._state[14],\n            ]);\n        }\n\n        result\n    }\n\n    #[inline_always]\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for PoseidonHasher {\n    fn default() -> Self {\n        PoseidonHasher { _state: &[] }\n    }\n}\n\nmod poseidon_tests {\n    use crate::hash::poseidon;\n\n    #[test]\n    fn reference_impl_test_vectors() {\n        // hardcoded test vectors from https://extgit.iaik.tugraz.at/krypto/hadeshash/-/blob/master/code/test_vectors.txt\n        {\n            let mut state = [0, 1, 2];\n            let mut expected = [\n                0x115cc0f5e7d690413df64c6b9662e9cf2a3617f2743245519e19607a4417189a,\n                0x0fca49b798923ab0239de1c9e7a4a9a2210312b6a2f616d18b5a87f9b628ae29,\n                0x0e7ae82e40091e63cbd4f16a6d16310b3729d4b6e138fcf54110e2867045a30c,\n            ];\n            assert_eq(\n                expected,\n                poseidon::bn254::perm::x5_3(state),\n                "Failed to reproduce output for [0, 1, 2]",\n            );\n        }\n        {\n            let mut state = [0, 1, 2, 3, 4];\n            let mut expected = [\n                0x299c867db6c1fdd79dcefa40e4510b9837e60ebb1ce0663dbaa525df65250465,\n                0x1148aaef609aa338b27dafd89bb98862d8bb2b429aceac47d86206154ffe053d,\n                0x24febb87fed7462e23f6665ff9a0111f4044c38ee1672c1ac6b0637d34f24907,\n                0x0eb08f6d809668a981c186beaf6110060707059576406b248e5d9cf6e78b3d3e,\n                0x07748bc6877c9b82c8b98666ee9d0626ec7f5be4205f79ee8528ef1c4a376fc7,\n            ];\n            assert_eq(\n                expected,\n                poseidon::bn254::perm::x5_5(state),\n                "Failed to reproduce output for [0, 1, 2, 3, 4]",\n            );\n        }\n    }\n}\n',
      path: 'std/hash/poseidon/mod.nr',
    },
    '61': {
      source:
        '#[export]\nfn poseidon2(inputs: [Field; 2]) -> Field {\n    std::hash::poseidon::bn254::hash_2(inputs)\n}\n\n#[export]\nfn poseidon4(inputs: [Field; 4]) -> Field {\n    std::hash::poseidon::bn254::hash_4(inputs)\n}\n',
      path: '/Users/brianbuilder/others/zkPal/contracts/zkPalLib/hashLib/src/lib.nr',
    },
  },
};

export const poseidon4_circuit: CompiledCircuit = {
  abi: {
    parameters: [
      {
        name: 'inputs',
        type: { kind: 'array', length: 4, type: { kind: 'field' } },
        visibility: 'private',
      },
    ],
    return_type: { abi_type: { kind: 'field' }, visibility: 'private' },
    error_types: {},
  },
  bytecode:
    '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',
  debug_symbols:
    '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',
  file_map: {
    '18': {
      source:
        'pub mod bn254;\nuse crate::{runtime::is_unconstrained, static_assert};\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        static_assert(\n            BIT_SIZE < modulus_num_bits() as u32,\n            "BIT_SIZE must be less than modulus_num_bits",\n        );\n        self.__assert_max_bit_size(BIT_SIZE);\n    }\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_le_bits)]\n    fn _to_le_bits<let N: u32>(self: Self) -> [u1; N] {}\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_be_bits)]\n    fn _to_be_bits<let N: u32>(self: Self) -> [u1; N] {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_le_bits\n        let bits = self._to_le_bits();\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[N - 1 - i] != p[N - 1 - i]) {\n                        assert(p[N - 1 - i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_be_bits\n        let bits = self._to_be_bits();\n\n        if !is_unconstrained() {\n            // Ensure that the decomposition does not overflow the modulus\n            let p = modulus_be_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[i] != p[i]) {\n                        assert(p[i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the \'self\',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            "N must be less than or equal to modulus_le_bytes().len()",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the \'self\',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            "N must be less than or equal to modulus_le_bytes().len()",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    // docs:start:to_le_radix\n    pub fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, "radix must be greater than 1");\n            static_assert(radix <= 256, "radix must be less than or equal to 256");\n            static_assert(radix & (radix - 1) == 0, "radix must be a power of 2");\n        }\n        self.__to_le_radix(radix)\n    }\n    // docs:end:to_le_radix\n\n    // docs:start:to_be_radix\n    pub fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            crate::assert_constant(radix);\n        }\n        self.__to_be_radix(radix)\n    }\n    // docs:end:to_be_radix\n\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // `_radix` must be less than 256\n    #[builtin(to_be_radix)]\n    fn __to_be_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            "N must be less than or equal to modulus_le_bytes().len()",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n/// An unconstrained only built in to efficiently compare fields.\n#[builtin(field_less_than)]\nunconstrained fn __field_less_than(x: Field, y: Field) -> bool {}\n\npub(crate) unconstrained fn field_less_than(x: Field, y: Field) -> bool {\n    __field_less_than(x, y)\n}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unconstrained context\n        unsafe {\n            field_less_than(x, y)\n        }\n    } else {\n        let x_bytes: [u8; 32] = x.to_le_bytes();\n        let y_bytes: [u8; 32] = y.to_le_bytes();\n        let mut x_is_lt = false;\n        let mut done = false;\n        for i in 0..32 {\n            if (!done) {\n                let x_byte = x_bytes[32 - 1 - i] as u8;\n                let y_byte = y_bytes[32 - 1 - i] as u8;\n                let bytes_match = x_byte == y_byte;\n                if !bytes_match {\n                    x_is_lt = x_byte < y_byte;\n                    done = true;\n                }\n            }\n        }\n        x_is_lt\n    }\n}\n\nmod tests {\n    use crate::{panic::panic, runtime};\n    use super::field_less_than;\n\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_bytes();\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_bytes();\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        // 259, in base 256, big endian, is [1, 3].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 1, 3]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        // 259, in base 256, little endian, is [3, 1].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bytes, [3, 1, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_radix_example\n\n    #[test(should_fail_with = "radix must be greater than 1")]\n    fn test_to_le_radix_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(f"radix must be greater than 1");\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be greater than 2\n    //#[test]\n    //fn test_to_le_radix_brillig_1() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(1);\n    //        crate::println(out);\n    //        let expected = [0; 8];\n    //        assert(out == expected, "unexpected result");\n    //    }\n    //}\n\n    #[test(should_fail_with = "radix must be a power of 2")]\n    fn test_to_le_radix_3() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(3);\n        } else {\n            panic(f"radix must be a power of 2");\n        }\n    }\n\n    #[test]\n    fn test_to_le_radix_brillig_3() {\n        // this test should only fail in constrained mode\n        if runtime::is_unconstrained() {\n            let field = 1;\n            let out: [u8; 8] = field.to_le_radix(3);\n            let mut expected = [0; 8];\n            expected[0] = 1;\n            assert(out == expected, "unexpected result");\n        }\n    }\n\n    #[test(should_fail_with = "radix must be less than or equal to 256")]\n    fn test_to_le_radix_512() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(512);\n        } else {\n            panic(f"radix must be less than or equal to 256")\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be less than 512\n    //#[test]\n    //fn test_to_le_radix_brillig_512() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(512);\n    //        let mut expected = [0; 8];\n    //        expected[0] = 1;\n    //        assert(out == expected, "unexpected result");\n    //    }\n    //}\n\n    #[test]\n    unconstrained fn test_field_less_than() {\n        assert(field_less_than(0, 1));\n        assert(field_less_than(0, 0x100));\n        assert(field_less_than(0x100, 0 - 1));\n        assert(!field_less_than(0 - 1, 0));\n    }\n}\n',
      path: 'std/field/mod.nr',
    },
    '22': {
      source:
        '// Instantiations of Poseidon permutation for the prime field of the same order as BN254\nuse crate::hash::poseidon::bn254::consts;\nuse crate::hash::poseidon::permute;\n\n#[field(bn254)]\npub fn x5_2(mut state: [Field; 2]) -> [Field; 2] {\n    state = permute(consts::x5_2_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_3(mut state: [Field; 3]) -> [Field; 3] {\n    state = permute(consts::x5_3_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_4(mut state: [Field; 4]) -> [Field; 4] {\n    state = permute(consts::x5_4_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_5(mut state: [Field; 5]) -> [Field; 5] {\n    state = permute(consts::x5_5_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_6(mut state: [Field; 6]) -> [Field; 6] {\n    state = permute(consts::x5_6_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_7(mut state: [Field; 7]) -> [Field; 7] {\n    state = permute(consts::x5_7_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_8(mut state: [Field; 8]) -> [Field; 8] {\n    state = permute(consts::x5_8_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_9(mut state: [Field; 9]) -> [Field; 9] {\n    state = permute(consts::x5_9_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_10(mut state: [Field; 10]) -> [Field; 10] {\n    state = permute(consts::x5_10_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_11(mut state: [Field; 11]) -> [Field; 11] {\n    state = permute(consts::x5_11_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_12(mut state: [Field; 12]) -> [Field; 12] {\n    state = permute(consts::x5_12_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_13(mut state: [Field; 13]) -> [Field; 13] {\n    state = permute(consts::x5_13_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_14(mut state: [Field; 14]) -> [Field; 14] {\n    state = permute(consts::x5_14_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_15(mut state: [Field; 15]) -> [Field; 15] {\n    state = permute(consts::x5_15_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_16(mut state: [Field; 16]) -> [Field; 16] {\n    state = permute(consts::x5_16_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_17(mut state: [Field; 17]) -> [Field; 17] {\n    state = permute(consts::x5_17_config(), state);\n\n    state\n}\n',
      path: 'std/hash/poseidon/bn254/perm.nr',
    },
    '23': {
      source:
        "// Instantiations of Poseidon constants, permutations and sponge for prime field of the same order as BN254\npub mod perm;\npub mod consts;\n\nuse crate::hash::poseidon::absorb;\n\n// Variable-length Poseidon-128 sponge as suggested in second bullet point of section 3 of https://eprint.iacr.org/2019/458.pdf\n#[field(bn254)]\npub fn sponge<let N: u32>(msg: [Field; N]) -> Field {\n    absorb(consts::x5_5_config(), [0; 5], 4, 1, msg)[1]\n}\n\n// Various instances of the Poseidon hash function\n// Consistent with Circom's implementation\n#[no_predicates]\npub fn hash_1(input: [Field; 1]) -> Field {\n    let mut state = [0; 2];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_2(state)[0]\n}\n\n#[no_predicates]\npub fn hash_2(input: [Field; 2]) -> Field {\n    let mut state = [0; 3];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_3(state)[0]\n}\n\n#[no_predicates]\npub fn hash_3(input: [Field; 3]) -> Field {\n    let mut state = [0; 4];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_4(state)[0]\n}\n\n#[no_predicates]\npub fn hash_4(input: [Field; 4]) -> Field {\n    let mut state = [0; 5];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_5(state)[0]\n}\n\n#[no_predicates]\npub fn hash_5(input: [Field; 5]) -> Field {\n    let mut state = [0; 6];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_6(state)[0]\n}\n\n#[no_predicates]\npub fn hash_6(input: [Field; 6]) -> Field {\n    let mut state = [0; 7];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_7(state)[0]\n}\n\n#[no_predicates]\npub fn hash_7(input: [Field; 7]) -> Field {\n    let mut state = [0; 8];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_8(state)[0]\n}\n\n#[no_predicates]\npub fn hash_8(input: [Field; 8]) -> Field {\n    let mut state = [0; 9];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_9(state)[0]\n}\n\n#[no_predicates]\npub fn hash_9(input: [Field; 9]) -> Field {\n    let mut state = [0; 10];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_10(state)[0]\n}\n\n#[no_predicates]\npub fn hash_10(input: [Field; 10]) -> Field {\n    let mut state = [0; 11];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_11(state)[0]\n}\n\n#[no_predicates]\npub fn hash_11(input: [Field; 11]) -> Field {\n    let mut state = [0; 12];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_12(state)[0]\n}\n\n#[no_predicates]\npub fn hash_12(input: [Field; 12]) -> Field {\n    let mut state = [0; 13];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_13(state)[0]\n}\n\n#[no_predicates]\npub fn hash_13(input: [Field; 13]) -> Field {\n    let mut state = [0; 14];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_14(state)[0]\n}\n\n#[no_predicates]\npub fn hash_14(input: [Field; 14]) -> Field {\n    let mut state = [0; 15];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_15(state)[0]\n}\n\n#[no_predicates]\npub fn hash_15(input: [Field; 15]) -> Field {\n    let mut state = [0; 16];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_16(state)[0]\n}\n\n#[no_predicates]\npub fn hash_16(input: [Field; 16]) -> Field {\n    let mut state = [0; 17];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_17(state)[0]\n}\n",
      path: 'std/hash/poseidon/bn254.nr',
    },
    '24': {
      source:
        'pub mod bn254; // Instantiations of Poseidon for prime field of the same order as BN254\nuse crate::default::Default;\nuse crate::hash::Hasher;\n\n// A config struct defining the parameters of the Poseidon instance to use.\n//\n// A thorough writeup of this method (along with an unoptimized method) can be found at: https://spec.filecoin.io/algorithms/crypto/poseidon/\npub struct PoseidonConfig<let T: u32, let N: u32, let X: u32> {\n    // State width, should be equal to `T`\n    t: Field,\n    // Number of full rounds. should be even\n    rf: u8,\n    // Number of partial rounds\n    rp: u8,\n    // S-box power; depends on the underlying field\n    alpha: Field,\n    // The round constants for the\n    round_constants: [Field; N],\n    // The MDS matrix for the Poseidon instance\n    mds: [[Field; T]; T],\n    // An MDS matrix which also applies a basis transformation which allows\n    // sparse matrices to be used for the partial rounds.\n    //\n    // This should be applied instead of `mds` in the final full round.\n    presparse_mds: [[Field; T]; T],\n    // A set of sparse matrices used for MDS mixing for the partial rounds.\n    sparse_mds: [Field; X],\n}\n\npub fn config<let T: u32, let N: u32, let X: u32>(\n    t: Field,\n    rf: u8,\n    rp: u8,\n    alpha: Field,\n    round_constants: [Field; N],\n    mds: [[Field; T]; T],\n    presparse_mds: [[Field; T]; T],\n    sparse_mds: [Field; X],\n) -> PoseidonConfig<T, N, X> {\n    // Input checks\n    assert_eq(rf & 1, 0);\n    assert_eq((t as u8) * rf + rp, N as u8);\n    assert_eq(t, T as Field);\n    assert(alpha != 0);\n\n    PoseidonConfig { t, rf, rp, alpha, round_constants, mds, presparse_mds, sparse_mds }\n}\n\npub fn permute<let T: u32, let N: u32, let X: u32>(\n    pos_conf: PoseidonConfig<T, N, X>,\n    mut state: [Field; T],\n) -> [Field; T] {\n    let PoseidonConfig { t, rf, rp, alpha, round_constants, mds, presparse_mds, sparse_mds } =\n        pos_conf;\n\n    for i in 0..state.len() {\n        state[i] += round_constants[i];\n    }\n\n    for _r in 0..rf / 2 - 1 {\n        state = sigma(state);\n        for i in 0..T {\n            state[i] += round_constants[T * (_r + 1) as u32 + i];\n        }\n        state = apply_matrix(mds, state);\n    }\n\n    state = sigma(state);\n    for i in 0..T {\n        state[i] += round_constants[T * (rf / 2) as u32 + i];\n    }\n    state = apply_matrix(presparse_mds, state);\n\n    for i in 0..T {\n        crate::as_witness(state[i]);\n    }\n\n    for _r in 0..rp {\n        state[0] = state[0].pow_32(alpha);\n        state[0] += round_constants[(rf / 2 + 1) as u32 * T + _r as u32];\n        crate::as_witness(state[0]);\n        {\n            let mut newState0 = 0;\n            for j in 0..T {\n                newState0 += sparse_mds[(T * 2 - 1) * _r as u32 + j as u32] * state[j];\n            }\n            for k in 1..T {\n                state[k] += state[0] * sparse_mds[(t * 2 - 1) as u32 * _r as u32 + T + k - 1];\n            }\n            state[0] = newState0;\n\n            if (_r & 1 == 0) {\n                for k in 1..T {\n                    crate::as_witness(state[k]);\n                }\n            }\n        }\n    }\n\n    for _r in 0..rf / 2 - 1 {\n        state = sigma(state);\n        for i in 0..state.len() {\n            state[i] += round_constants[(rf / 2 + 1) as u32 * T + rp as u32 + (_r as u32) * T + i];\n        }\n        state = apply_matrix(mds, state);\n    }\n\n    state = sigma(state);\n    state = apply_matrix(mds, state);\n\n    state\n}\n\n// Performs matrix multiplication on a vector\nfn apply_matrix<let N: u32>(matrix: [[Field; N]; N], vec: [Field; N]) -> [Field; N] {\n    let mut out = [0; N];\n\n    for i in 0..N {\n        for j in 0..N {\n            out[i] += vec[j] * matrix[j][i];\n        }\n    }\n\n    out\n}\n\n// Corresponding absorption.\nfn absorb<let T: u32, let N: u32, let X: u32, let O: u32>(\n    pos_conf: PoseidonConfig<T, N, X>,\n    // Initial state; usually [0; O]\n    mut state: [Field; T],\n    rate: Field,\n    capacity: Field,\n    msg: [Field; O], // Arbitrary length message\n) -> [Field; T] {\n    assert_eq(pos_conf.t, rate + capacity);\n\n    let mut i = 0;\n\n    for k in 0..msg.len() {\n        // Add current block to state\n        state[capacity + i] += msg[k];\n        i = i + 1;\n        // Enough to absorb\n        if i == rate {\n            state = permute(pos_conf, state);\n            i = 0;\n        }\n    }\n    // If we have one more block to permute\n    if i != 0 {\n        state = permute(pos_conf, state);\n    }\n\n    state\n}\n\nfn sigma<let O: u32>(x: [Field; O]) -> [Field; O] {\n    let mut y = x;\n    for i in 0..O {\n        let t = y[i];\n        let tt = t * t;\n        let tttt = tt * tt;\n        y[i] *= tttt;\n    }\n    y\n}\n\npub struct PoseidonHasher {\n    _state: [Field],\n}\n\nimpl Hasher for PoseidonHasher {\n    #[field(bn254)]\n    fn finish(self) -> Field {\n        let mut result = 0;\n        let len = self._state.len();\n        assert(len < 16);\n        if len == 1 {\n            result = bn254::hash_1([self._state[0]]);\n        }\n        if len == 2 {\n            result = bn254::hash_2([self._state[0], self._state[1]]);\n        }\n        if len == 3 {\n            result = bn254::hash_3([self._state[0], self._state[1], self._state[2]]);\n        }\n        if len == 4 {\n            result = bn254::hash_4([self._state[0], self._state[1], self._state[2], self._state[3]]);\n        }\n        if len == 5 {\n            result = bn254::hash_5([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n            ]);\n        }\n        if len == 6 {\n            result = bn254::hash_6([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n                self._state[5],\n            ]);\n        }\n        if len == 7 {\n            result = bn254::hash_7([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n                self._state[5],\n                self._state[6],\n            ]);\n        }\n        if len == 8 {\n            result = bn254::hash_8([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n                self._state[5],\n                self._state[6],\n                self._state[7],\n            ]);\n        }\n        if len == 9 {\n            result = bn254::hash_9([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n                self._state[5],\n                self._state[6],\n                self._state[7],\n                self._state[8],\n            ]);\n        }\n        if len == 10 {\n            result = bn254::hash_10([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n                self._state[5],\n                self._state[6],\n                self._state[7],\n                self._state[8],\n                self._state[9],\n            ]);\n        }\n        if len == 11 {\n            result = bn254::hash_11([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n                self._state[5],\n                self._state[6],\n                self._state[7],\n                self._state[8],\n                self._state[9],\n                self._state[10],\n            ]);\n        }\n        if len == 12 {\n            result = bn254::hash_12([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n                self._state[5],\n                self._state[6],\n                self._state[7],\n                self._state[8],\n                self._state[9],\n                self._state[10],\n                self._state[11],\n            ]);\n        }\n        if len == 13 {\n            result = bn254::hash_13([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n                self._state[5],\n                self._state[6],\n                self._state[7],\n                self._state[8],\n                self._state[9],\n                self._state[10],\n                self._state[11],\n                self._state[12],\n            ]);\n        }\n        if len == 14 {\n            result = bn254::hash_14([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n                self._state[5],\n                self._state[6],\n                self._state[7],\n                self._state[8],\n                self._state[9],\n                self._state[10],\n                self._state[11],\n                self._state[12],\n                self._state[13],\n            ]);\n        }\n        if len == 15 {\n            result = bn254::hash_15([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n                self._state[5],\n                self._state[6],\n                self._state[7],\n                self._state[8],\n                self._state[9],\n                self._state[10],\n                self._state[11],\n                self._state[12],\n                self._state[13],\n                self._state[14],\n            ]);\n        }\n\n        result\n    }\n\n    #[inline_always]\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for PoseidonHasher {\n    fn default() -> Self {\n        PoseidonHasher { _state: &[] }\n    }\n}\n\nmod poseidon_tests {\n    use crate::hash::poseidon;\n\n    #[test]\n    fn reference_impl_test_vectors() {\n        // hardcoded test vectors from https://extgit.iaik.tugraz.at/krypto/hadeshash/-/blob/master/code/test_vectors.txt\n        {\n            let mut state = [0, 1, 2];\n            let mut expected = [\n                0x115cc0f5e7d690413df64c6b9662e9cf2a3617f2743245519e19607a4417189a,\n                0x0fca49b798923ab0239de1c9e7a4a9a2210312b6a2f616d18b5a87f9b628ae29,\n                0x0e7ae82e40091e63cbd4f16a6d16310b3729d4b6e138fcf54110e2867045a30c,\n            ];\n            assert_eq(\n                expected,\n                poseidon::bn254::perm::x5_3(state),\n                "Failed to reproduce output for [0, 1, 2]",\n            );\n        }\n        {\n            let mut state = [0, 1, 2, 3, 4];\n            let mut expected = [\n                0x299c867db6c1fdd79dcefa40e4510b9837e60ebb1ce0663dbaa525df65250465,\n                0x1148aaef609aa338b27dafd89bb98862d8bb2b429aceac47d86206154ffe053d,\n                0x24febb87fed7462e23f6665ff9a0111f4044c38ee1672c1ac6b0637d34f24907,\n                0x0eb08f6d809668a981c186beaf6110060707059576406b248e5d9cf6e78b3d3e,\n                0x07748bc6877c9b82c8b98666ee9d0626ec7f5be4205f79ee8528ef1c4a376fc7,\n            ];\n            assert_eq(\n                expected,\n                poseidon::bn254::perm::x5_5(state),\n                "Failed to reproduce output for [0, 1, 2, 3, 4]",\n            );\n        }\n    }\n}\n',
      path: 'std/hash/poseidon/mod.nr',
    },
    '61': {
      source:
        '#[export]\nfn poseidon2(inputs: [Field; 2]) -> Field {\n    std::hash::poseidon::bn254::hash_2(inputs)\n}\n\n#[export]\nfn poseidon4(inputs: [Field; 4]) -> Field {\n    std::hash::poseidon::bn254::hash_4(inputs)\n}\n',
      path: '/Users/brianbuilder/others/zkPal/contracts/zkPalLib/hashLib/src/lib.nr',
    },
  },
};
